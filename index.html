<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Viewer ‚Äî Pro</title>

  <!-- Import map for bare specifier "three" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
    }
  }
  </script>

  <style>
    :root{
      /* Light theme (default) */
      --panel-w: 360px;
      --bg-page: #f5f7fc;
      --bg-panel: #ffffff;
      --text: #0b1220;
      --muted: #5b667a;
      --accent: #2563eb;
      --danger: #ef4444;
      --ok: #10b981;
      --border: #d9deea;
      --chip-bg:#fff;
      --chip-bd:#e6ebf7;
      --chip-tx:#344054;
      --toast-bg:#111827; --toast-bd:#1f2937; --toast-tx:#e5edff;
      --button-hover:#f6f8fe;
      --button-checked:#f3f7ff;
      --tree-sel-bg:#eef3ff; --tree-sel-bd:#c8d5ff;
      --progress-bg:#fff; --progress-bd:#e6ebf7; --meter-bg:#eef2fb; --meter-bd:#e1e7fb;
      --grid-c1:#8892a6; --grid-c2:#cbd5e1;
      --canvas-default:#ffffff; /* canvas scene background default (white) */
    }
    body.theme-dark{
      /* Dark theme overrides */
      --bg-page:#0b0d12;
      --bg-panel:#121520;
      --text:#e9eef5;
      --muted:#a9b3c7;
      --accent:#4da3ff;
      --danger:#ff5e7a;
      --ok:#4cd480;
      --border:#222736;
      --chip-bg:#0f1322; --chip-bd:#1b213d; --chip-tx:#b7c5e6;
      --toast-bg:#0f1528; --toast-bd:#1b2240; --toast-tx:#cfe0ff;
      --button-hover:#161a28;
      --button-checked:#0d1420;
      --tree-sel-bg:#1a2542; --tree-sel-bd:#2c3e6a;
      --progress-bg:#0f1322; --progress-bd:#1c2340; --meter-bg:#0b1020; --meter-bd:#1b2446;
      --grid-c1:#293347; --grid-c2:#1b2233;
      --canvas-default:#0b0d12;
    }

    html, body{ margin:0; padding:0; height:100%; background: var(--bg-page); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .viewer-wrap{ position:fixed; inset:0; overflow:hidden; }
    canvas.viewer-canvas{ position:absolute; inset:0; display:block; outline: none; }

    .left-col{
      position: fixed; top: 0; left: 0; bottom: 0; width: var(--panel-w); max-width: 92vw;
      background: var(--bg-panel);
      border-right: 1px solid var(--border);
      padding: 12px 12px 16px;
      display:flex; flex-direction:column; gap:12px; z-index: 30;
      box-shadow: 0 0 30px rgba(0,0,0,.06);
    }
    .left-col header{ display:flex; align-items:center; gap:10px; }
    .logo-dot{ width:10px; height:10px; border-radius:50%; background: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent); }
    .left-col h1{ font-size: 16px; margin:0; font-weight: 700; letter-spacing: .2px; }
    .toolbar{ display:flex; gap:8px; flex-wrap:wrap; }
    .btn, .toggle{
      appearance:none; border:1px solid var(--border); background: var(--bg-panel); color: var(--text);
      padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: .15s transform, .15s background, .15s border-color;
      font-size: 13px; line-height: 1; display:inline-flex; gap:8px; align-items:center;
    }
    .btn:hover, .toggle:hover{ background:var(--button-hover); border-color:color-mix(in srgb, var(--border) 60%, transparent); transform: translateY(-1px) }
    .btn.secondary{ background: color-mix(in srgb, var(--bg-panel) 90%, white); }
    .btn.danger{ border-color: color-mix(in srgb, var(--danger) 25%, var(--border)); background: color-mix(in srgb, var(--danger) 8%, var(--bg-panel)); color:color-mix(in srgb, var(--danger) 60%, black); }
    .btn.ok{ border-color:color-mix(in srgb, var(--ok) 25%, var(--border)); background:color-mix(in srgb, var(--ok) 8%, var(--bg-panel)); color:color-mix(in srgb, var(--ok) 65%, black); }
    .toggle input{ display:none; }
    .toggle:has(input:checked){ border-color:color-mix(in srgb, var(--accent) 30%, var(--border)); background:var(--button-checked); }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .row label{ font-size:12px; color: var(--muted) }
    .field{ background:var(--bg-panel); border:1px solid var(--border); border-radius: 8px; padding:6px 8px; color:var(--text) }
    .split{ height:1px; background:var(--border); opacity:.5; margin: 4px 0 }
    .group{ display:flex; flex-direction:column; gap:8px }
    .scroll{ overflow:auto; }
    .small{ font-size:12px; color: var(--muted) }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:var(--chip-bg); border:1px solid var(--chip-bd); border-radius:6px; padding:1px 6px; font-size:11px; color:var(--chip-tx) }

    .inspector{
      position: fixed; top:0; right: calc(-1 * var(--panel-w)); bottom:0; width: var(--panel-w);
      background: var(--bg-panel);
      border-left:1px solid var(--border);
      transition: right .25s ease;
      z-index: 40; display:flex; flex-direction:column; box-shadow: 0 0 30px rgba(0,0,0,.06);
    }
    .inspector.right-0{ right: 0 }
    .inspector header{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; gap:8px; border-bottom:1px solid var(--border) }
    .inspector .tree{ flex:1; overflow:auto; padding: 10px 8px; }
    .tag{ font-size:11px; padding: 2px 6px; border-radius: 999px; background:var(--chip-bg); border:1px solid var(--chip-bd); color:var(--chip-tx) }
    .tree ul{ list-style:none; padding-left: 14px; margin: 0 }
    .tree li{ margin: 2px 0 }
    .tree button{ background: none; border:1px solid transparent; color: var(--text); cursor: pointer; padding: 2px 6px; border-radius: 6px }
    .tree button:hover{ background:var(--button-hover); border-color:color-mix(in srgb, var(--border) 60%, transparent) }
    .tree .selected{ background:var(--tree-sel-bg); border-color:var(--tree-sel-bd) }

    .overlay{ position:fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.6); z-index: 50; }
    .overlay.show{ display:grid }
    .progress{
      min-width: 280px; max-width: 60vw; background:var(--progress-bg); border:1px solid var(--progress-bd); border-radius: 12px; padding:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.15);
    }
    .progress h3{ margin:0 0 8px 0; font-size:14px }
    .meter{ height: 8px; background: var(--meter-bg); border:1px solid var(--meter-bd); border-radius: 999px; overflow:hidden }
    .meter > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, #60a5fa, #93c5fd); transition: width .15s }
    .indeterminate{ position:relative; overflow:hidden }
    .indeterminate > i{ position:absolute; width:40%; left:-40%; animation: roll 1.2s infinite linear }
    @keyframes roll { to { left: 100% } }

    .toast{
      position:fixed; left: 12px; bottom: 12px; z-index: 60; padding: 10px 12px;
      background:var(--toast-bg); border:1px solid var(--toast-bd); color:var(--toast-tx); border-radius: 10px; box-shadow: 0 10px 20px rgba(0,0,0,.25);
      display:none;
    }
    .toast.show{ display:block }
    .debug{
      position:fixed; left:12px; right: calc(var(--panel-w) + 12px); bottom: 12px; z-index: 20;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; pointer-events:none;
    }
    .chip{ pointer-events:auto; background:var(--chip-bg); border:1px solid var(--chip-bd); border-radius: 999px; padding: 6px 10px; font-size:12px; color:var(--chip-tx) }
    .chip b{ color:var(--text) }
    .open-inspector-tab{
      position: fixed; top: 50%; right: 0; transform: translateY(-50%);
      z-index: 35; padding: 8px 10px; border-radius: 10px 0 0 10px;
      background:var(--bg-panel); border:1px solid var(--border); border-right: none; cursor: pointer;
      box-shadow: 0 4px 16px rgba(0,0,0,.08);
    }
    .range{ width: 220px }
    .lang-select{ margin-left:auto }
    .theme-switch{
      margin-left:4px;
      display:inline-flex; align-items:center; gap:6px;
      border:1px solid var(--border); background:var(--bg-panel); padding:6px 8px; border-radius:10px; cursor:pointer;
    }
    .theme-switch .icon{ width:16px; height:16px; display:inline-block }
  </style>
</head>
<body>
  <div class="viewer-wrap" id="drop-zone" aria-label="3D Viewer">
    <canvas class="viewer-canvas" id="viewport" tabindex="0"></canvas>
  </div>

  <aside class="left-col" aria-label="Controls">
    <header>
      <span class="logo-dot" aria-hidden="true"></span>
      <h1 data-i="title">3D Viewer</h1>
      <button id="theme-toggle" class="theme-switch" title="Theme">
        <span class="icon" id="theme-icon">üåû</span>
        <span id="theme-label">Light</span>
      </button>
      <select id="lang" class="field lang-select">
        <option value="ru">–†—É—Å—Å–∫–∏–π</option>
        <option value="en">English</option>
      </select>
    </header>

    <div class="group">
      <div class="toolbar">
        <label class="btn">
          <input id="file-input" type="file" accept=".gltf,.glb,.fbx,.obj,.bin,.dae,.vrm,.zip" hidden />
          <span data-i="btnLoad">–ó–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å</span>
        </label>
        <button id="reset-camera" class="btn secondary" data-i="btnFrame">–ö –∫–∞–º–µ—Ä–µ</button>
        <button id="clear-scene" class="btn danger" data-i="btnClear">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>

      <div class="row">
        <label class="toggle"><input type="checkbox" id="toggle-shadows" /><span data-i="toggleShadows">–¢–µ–Ω–∏</span></label>
        <label class="toggle"><input type="checkbox" id="toggle-fxaa" checked /><span>FXAA</span></label>
        <label class="toggle"><input type="checkbox" id="toggle-lightonly" /><span data-i="toggleLight">–¢–æ–ª—å–∫–æ –æ—Å–≤–µ—â–µ–Ω–∏–µ</span></label>
        <label class="toggle"><input type="checkbox" id="toggle-grid" checked /><span data-i="toggleGrid">–°–µ—Ç–∫–∞</span></label>
      </div>

      <div class="row">
        <label data-i="bgLabel">–§–æ–Ω</label>
        <select id="bg-select" class="field">
          <option value="white" selected>–ë–µ–ª—ã–π</option>
          <option value="lightgray">–°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π</option>
          <option value="midgray">–°—Ä–µ–¥–Ω–µ-—Å–µ—Ä—ã–π</option>
          <option value="darkgray">–¢—ë–º–Ω—ã–π</option>
          <option value="transparent">–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π</option>
          <option value="custom">–ü—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π</option>
        </select>
        <input id="bg-color" class="field" type="color" value="#ffffff" title="Custom" />
      </div>

      <div class="row">
        <label>HDRI</label>
        <input class="field" type="text" id="hdri-url" placeholder="URL .hdr" />
        <button id="apply-hdri" class="btn" data-i="btnApply">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
      </div>

      <div class="row">
        <label data-i="matOverride">–ú–∞—Ç–µ—Ä–∏–∞–ª</label>
        <select id="mat-override" class="field">
          <option value="none" selected>–û—Ä–∏–≥–∏–Ω–∞–ª</option>
          <option value="standard">Standard</option>
          <option value="phong">Phong</option>
          <option value="basic">Basic</option>
          <option value="normal">Normal</option>
          <option value="toon">Toon</option>
        </select>
        <label class="toggle"><input type="checkbox" id="toggle-wireframe" /><span data-i="wireframe">–ö–∞—Ä–∫–∞—Å</span></label>
      </div>

      <div class="split"></div>

      <div class="group">
        <label class="small" data-i="animTitle">–ê–Ω–∏–º–∞—Ü–∏–∏</label>
        <div class="row" id="anim-row">
          <select id="anim-select" class="field" style="min-width:200px"></select>
          <button id="anim-playpause" class="btn ok" data-i="animPlay">–ü—É—Å–∫</button>
          <button id="anim-stop" class="btn" data-i="animStop">–°—Ç–æ–ø</button>
          <label class="toggle"><input type="checkbox" id="anim-loop" checked /><span data-i="animLoop">–ó–∞—Ü–∏–∫–ª–∏—Ç—å</span></label>
          <label class="row small">
            <span data-i="animSpeed">–°–∫–æ—Ä–æ—Å—Ç—å</span>
            <input id="anim-speed" class="field" type="number" step="0.25" min="0.25" max="3" value="1" style="width:70px" />
            <span>x</span>
          </label>
        </div>
        <div class="row">
          <input id="anim-progress" class="range" type="range" min="0" max="1" step="0.001" value="0" />
          <span class="small" id="anim-time">0.00 / 0.00s</span>
        </div>
        <div class="small" data-i="animHint">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–∏–º–∞—Ü–∏—è –Ω–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç—Å—è.</div>
      </div>
    </div>

    <div class="split"></div>

    <div class="group scroll" style="min-height: 0">
      <label class="small" data-i="hotkeys">–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏</label>
      <div class="row small">
        <span class="kbd">LMB</span> <span data-i="hkSelect">–≤—ã–±–æ—Ä</span>
        <span class="kbd">F</span> <span data-i="hkFocus">–∫ –æ–±—ä–µ–∫—Ç—É</span>
        <span class="kbd">R</span> <span data-i="hkReset">—Å–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã</span>
        <span class="kbd">Del</span> <span data-i="hkClearSel">—Å–Ω—è—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ</span>
      </div>
    </div>
  </aside>

  <aside id="scene-inspector" class="inspector right-[-360px]" aria-label="Scene Inspector">
    <header>
      <strong data-i="inspector">–°—Ü–µ–Ω–∞</strong>
      <div class="row">
        <span class="tag" id="poly-count">‚Äî</span>
        <button class="btn" id="inspector-close" data-i="btnHideInspector">–°–∫—Ä—ã—Ç—å</button>
      </div>
    </header>
    <div class="tree" id="tree"></div>
  </aside>

  <button class="open-inspector-tab" id="open-inspector" title="Inspector">‚ò∞</button>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <div class="overlay" id="overlay">
    <div class="progress">
      <h3 id="progress-title">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</h3>
      <div class="meter indeterminate" id="meter"><i></i></div>
      <div class="small" id="progress-sub">–û–∂–∏–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ‚Ä¶</div>
    </div>
  </div>

  <div class="debug" id="debug-bar">
    <div class="chip"><b>FPS:</b> <span id="fps">‚Äî</span></div>
    <div class="chip"><b data-i="objects">–û–±—ä–µ–∫—Ç—ã:</b> <span id="obj-count">‚Äî</span></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/FBXLoader.js';
    import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/KTX2Loader.js';
    import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/meshoptimizer@0.20.0/meshopt_decoder.module.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
    import { OutlinePass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/OutlinePass.js';
    import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/shaders/FXAAShader.js';
    import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/RGBELoader.js';

    // ======= i18n =======
    const i18n = {
      ru: {
        title: '3D Viewer', btnLoad:'–ó–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å', btnFrame:'–ö –∫–∞–º–µ—Ä–µ', btnClear:'–û—á–∏—Å—Ç–∏—Ç—å',
        toggleShadows:'–¢–µ–Ω–∏', toggleLight:'–¢–æ–ª—å–∫–æ –æ—Å–≤–µ—â–µ–Ω–∏–µ', toggleGrid:'–°–µ—Ç–∫–∞', bgLabel:'–§–æ–Ω', btnApply:'–ü—Ä–∏–º–µ–Ω–∏—Ç—å',
        matOverride:'–ú–∞—Ç–µ—Ä–∏–∞–ª', wireframe:'–ö–∞—Ä–∫–∞—Å',
        animTitle:'–ê–Ω–∏–º–∞—Ü–∏–∏', animPlay:'–ü—É—Å–∫', animPause:'–ü–∞—É–∑–∞', animStop:'–°—Ç–æ–ø', animLoop:'–ó–∞—Ü–∏–∫–ª–∏—Ç—å', animSpeed:'–°–∫–æ—Ä–æ—Å—Ç—å',
        animHint:'–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–∏–º–∞—Ü–∏—è –Ω–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç—Å—è.', hotkeys:'–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏',
        hkSelect:'–≤—ã–±–æ—Ä', hkFocus:'–∫ –æ–±—ä–µ–∫—Ç—É', hkReset:'—Å–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã', hkClearSel:'—Å–Ω—è—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ',
        inspector:'–°—Ü–µ–Ω–∞', btnHideInspector:'–°–∫—Ä—ã—Ç—å', btnShowInspector:'–ò–Ω—Å–ø–µ–∫—Ç–æ—Ä', objects:'–û–±—ä–µ–∫—Ç—ã:'
      },
      en: {
        title: '3D Viewer', btnLoad:'Load model', btnFrame:'Frame', btnClear:'Clear',
        toggleShadows:'Shadows', toggleLight:'Light only', toggleGrid:'Grid', bgLabel:'Background', btnApply:'Apply',
        matOverride:'Material', wireframe:'Wireframe',
        animTitle:'Animations', animPlay:'Play', animPause:'Pause', animStop:'Stop', animLoop:'Loop', animSpeed:'Speed',
        animHint:'By default animations do not play.', hotkeys:'Hotkeys',
        hkSelect:'select', hkFocus:'focus', hkReset:'reset camera', hkClearSel:'clear selection',
        inspector:'Scene', btnHideInspector:'Hide', btnShowInspector:'Inspector', objects:'Objects:'
      }
    };
    function applyLang(lang){
      document.querySelectorAll('[data-i]').forEach(el=>{
        const key = el.getAttribute('data-i');
        if (i18n[lang][key] !== undefined) el.textContent = i18n[lang][key];
      });
      openInspectorBtn.title = i18n[lang].btnShowInspector;
      themeLabel.textContent = (lang==='ru' ? (isDark() ? '–ù–æ—á–Ω–∞—è' : '–°–≤–µ—Ç–ª–∞—è') : (isDark() ? 'Dark' : 'Light'));
      saveSettings();
    }

    // ======= Local storage =======
    const LS_KEY = 'viewerSettings.v1';
    function loadSettings(){
      try{ return JSON.parse(localStorage.getItem(LS_KEY)) || {}; }catch{ return {}; }
    }
    function saveSettings(){
      const s = {
        lang: langSelect.value,
        theme: isDark() ? 'dark' : 'light',
        toggles:{
          shadows: toggleShadows.checked,
          fxaa: toggleFXAA.checked,
          lightonly: toggleLightOnly.checked,
          grid: toggleGrid.checked
        },
        background:{ mode: bgSelect.value, color: bgColor.value },
        hdri: hdriUrlInput.value.trim(),
        material:{ override: matOverride.value, wireframe: toggleWireframe.checked },
        anim:{ loop: animLoop.checked, speed: parseFloat(animSpeed.value)||1 }
      };
      localStorage.setItem(LS_KEY, JSON.stringify(s));
    }

    // ======= DOM =======
    const d = document;
    const canvas = d.getElementById('viewport');
    const leftCol = d.querySelector('.left-col');
    const inspector = d.getElementById('scene-inspector');
    const treeRoot = d.getElementById('tree');
    const inspectorClose = d.getElementById('inspector-close');
    const openInspectorBtn = d.getElementById('open-inspector');
    const polyCountEl = d.getElementById('poly-count');
    const toastEl = d.getElementById('toast');
    const overlay = d.getElementById('overlay');
    const meter = d.getElementById('meter');
    const progressTitle = d.getElementById('progress-title');
    const progressSub = d.getElementById('progress-sub');
    const objCountEl = d.getElementById('obj-count');
    const fpsEl = d.getElementById('fps');

    const langSelect = d.getElementById('lang');
    const themeToggle = d.getElementById('theme-toggle');
    const themeIcon = d.getElementById('theme-icon');
    const themeLabel = d.getElementById('theme-label');

    const fileInput = d.getElementById('file-input');
    const resetCameraBtn = d.getElementById('reset-camera');
    const clearSceneBtn = d.getElementById('clear-scene');
    const toggleShadows = d.getElementById('toggle-shadows');
    const toggleFXAA = d.getElementById('toggle-fxaa');
    const toggleLightOnly = d.getElementById('toggle-lightonly');
    const toggleGrid = d.getElementById('toggle-grid');
    const bgSelect = d.getElementById('bg-select');
    const bgColor = d.getElementById('bg-color');
    const hdriUrlInput = d.getElementById('hdri-url');
    const applyHdriBtn = d.getElementById('apply-hdri');

    const matOverride = d.getElementById('mat-override');
    const toggleWireframe = d.getElementById('toggle-wireframe');

    const animSelect = d.getElementById('anim-select');
    const animPlayPause = d.getElementById('anim-playpause');
    const animStop = d.getElementById('anim-stop');
    const animLoop = d.getElementById('anim-loop');
    const animSpeed = d.getElementById('anim-speed');
    const animProgress = d.getElementById('anim-progress');
    const animTime = d.getElementById('anim-time');

    const dropZone = d.getElementById('drop-zone');

    // ======= THREE setup =======
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:false, alpha:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = false;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(getComputedStyle(d.body).getPropertyValue('--canvas-default').trim());

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 50000);
    camera.position.set(2, 1.2, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0.8, 0);
    controls.update();

    // Grid (adaptive)
    let grid = null;
    function createGrid(size=10, divisions=20){
      if (grid){ scene.remove(grid); grid.geometry.dispose(); grid.material.dispose(); grid=null; }
      grid = new THREE.GridHelper(size, divisions, getColor('--grid-c1'), getColor('--grid-c2'));
      grid.material.transparent = true; grid.material.opacity = 0.6;
      grid.position.y = 0;
      scene.add(grid);
      grid.visible = toggleGrid.checked;
    }
    function getColor(cssVar){
      const v = getComputedStyle(d.body).getPropertyValue(cssVar).trim();
      return new THREE.Color(v);
    }
    createGrid(10, 20);

    const hemi = new THREE.HemisphereLight(0xffffff, 0xe2e8f0, 0.5);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(3,5,2);
    dir.castShadow = false;
    scene.add(dir);

    // Post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
    outlinePass.edgeStrength = 3.0;
    outlinePass.edgeGlow = 0.0;
    outlinePass.edgeThickness = 1.0;
    outlinePass.visibleEdgeColor.set(0x2563eb);
    outlinePass.hiddenEdgeColor.set(0x0);
    composer.addPass(outlinePass);

    const fxaaPass = new ShaderPass(FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
    composer.addPass(fxaaPass);

    // Animation
    let mixer = null;
    let currentClips = [];
    let activeAction = null;
    let clock = new THREE.Clock();

    // Current model state
    let currentModel = null;
    let savedOriginal = new WeakMap();
    let selectedObject = null;
    let envHdrTex = null;

    // Loaders
    const gltfLoader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/libs/draco/');
    gltfLoader.setDRACOLoader(dracoLoader);
    const ktx2 = new KTX2Loader()
      .setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/libs/basis/')
      .detectSupport(renderer);
    gltfLoader.setKTX2Loader(ktx2);
    gltfLoader.setMeshoptDecoder(MeshoptDecoder);
    const fbxLoader = new FBXLoader();
    const rgbeLoader = new RGBELoader();

    // ======= Theme =======
    function isDark(){ return d.body.classList.contains('theme-dark'); }
    function setTheme(theme){
      d.body.classList.toggle('theme-dark', theme === 'dark');
      themeIcon.textContent = theme === 'dark' ? 'üåô' : 'üåû';
      themeLabel.textContent = (langSelect.value === 'ru') ? (theme==='dark' ? '–ù–æ—á–Ω–∞—è' : '–°–≤–µ—Ç–ª–∞—è') : (theme==='dark' ? 'Dark' : 'Light');
      // Update scene background to theme default if not custom selection
      if (bgSelect.value === 'white' || bgSelect.value==='lightgray' || bgSelect.value==='midgray' || bgSelect.value==='darkgray'){
        updateBackgroundFromUI(); // will map to theme-agnostic colors
      } else if (bgSelect.value === 'transparent'){
        updateBackgroundFromUI();
      } else if (bgSelect.value === 'custom'){
        // keep custom
      } else {
        scene.background = new THREE.Color(getComputedStyle(d.body).getPropertyValue('--canvas-default').trim());
      }
      // Rebuild grid with theme colors
      createGrid(gridSize, gridDiv);
      saveSettings();
    }
    themeToggle.addEventListener('click', ()=> setTheme(isDark() ? 'light' : 'dark'));

    // ======= Inspector open/close =======
    function openInspector(open) {
      inspector.classList.toggle('right-0', open);
      inspector.classList.toggle('right-[-360px]', !open);
    }
    openInspectorBtn.addEventListener('click', ()=> openInspector(true));
    leftCol.addEventListener('dblclick', () => openInspector(true));
    inspectorClose.addEventListener('click', () => openInspector(false));

    // ======= Drag & Drop =======
    ;['dragenter','dragover'].forEach(evt=>dropZone.addEventListener(evt, (e)=>{
      e.preventDefault(); e.stopPropagation();
      showOverlay('–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶', '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª —Å—é–¥–∞');
    }));
    ;['dragleave','drop'].forEach(evt=>dropZone.addEventListener(evt, (e)=>{
      e.preventDefault(); e.stopPropagation();
      hideOverlay();
    }));
    dropZone.addEventListener('drop', (e)=>{
      const file = e.dataTransfer?.files?.[0];
      if (file) handleFile(file);
    });

    // ======= File input =======
    fileInput.addEventListener('change', (e)=>{
      const file = e.target.files?.[0];
      if (file) handleFile(file);
      fileInput.value = '';
    });

    function handleFile(file){
      const name = file.name.toLowerCase();
      if (name.endsWith('.gltf') || name.endsWith('.glb')) {
        loadGLTF(file);
      } else if (name.endsWith('.fbx')) {
        loadFBX(file);
      } else {
        toast('–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: glTF/GLB/FBX');
      }
    }

    // ======= Safe revoke URL helper =======
    function loadWithURL(loader, file, onSuccess, onProgress, onError){
      const url = URL.createObjectURL(file);
      loader.load(url, (asset)=>{
          URL.revokeObjectURL(url);
          onSuccess && onSuccess(asset);
        }, (evt)=>{
          if (evt && evt.lengthComputable) setProgress(evt.loaded / evt.total);
          else setIndeterminate();
          onProgress && onProgress(evt);
        }, (err)=>{
          URL.revokeObjectURL(url);
          onError && onError(err);
        });
    }

    // ======= Model lifecycle =======
    function disposeObject(obj){
      obj.traverse(o=>{
        if (o.isMesh){
          if (o.geometry) o.geometry.dispose();
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.filter(Boolean).forEach(m=>{
            ['map','normalMap','metalnessMap','roughnessMap','emissiveMap','aoMap','alphaMap','bumpMap','envMap']
              .forEach(k=>{ if (m && m[k]?.isTexture) m[k].dispose(); });
            m?.dispose?.();
          });
        }
      });
    }
    function clearCurrentModel(){
      if (currentModel){
        outlinePass.selectedObjects = [];
        selectObject(null);
        scene.remove(currentModel);
        disposeObject(currentModel);
        currentModel = null;
      }
      updateStats();
      buildSceneTree(null);
      resetAnimationsUI();
    }

    // ======= Material enhancement (arrays-safe) & override =======
    function enhanceMaterial(material){
      if (!material) return material;
      if (Array.isArray(material)) return material.map(m => enhanceMaterial(m));
      if (!(material instanceof THREE.MeshStandardMaterial)){
        const m = new THREE.MeshStandardMaterial({
          name: material.name || '',
          color: material.color ? material.color.clone() : new THREE.Color(0xcccccc),
          opacity: material.opacity ?? 1,
          transparent: !!material.transparent,
          side: material.side ?? THREE.FrontSide,
          wireframe: !!material.wireframe
        });
        if (material.map) { m.map = material.map; if (m.map) m.map.encoding = THREE.sRGBEncoding; }
        m.metalness = material.metalness ?? 0.0;
        m.roughness = material.roughness ?? 0.5;
        material = m;
      } else {
        if (material.map) material.map.encoding = THREE.sRGBEncoding;
      }
      material.needsUpdate = true;
      return material;
    }

    function makeOverride(type){
      switch(type){
        case 'standard': return new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0, roughness:0.5 });
        case 'phong':    return new THREE.MeshPhongMaterial({ color: 0xffffff, shininess:30 });
        case 'basic':    return new THREE.MeshBasicMaterial({ color: 0xffffff });
        case 'normal':   return new THREE.MeshNormalMaterial();
        case 'toon':     return new THREE.MeshToonMaterial({ color: 0xffffff });
        default: return null; // none
      }
    }
    function applyMaterialOverride(root){
      if (!root) return;
      const overrideType = matOverride.value;
      const wire = toggleWireframe.checked;
      const overrideMat = makeOverride(overrideType);
      root.traverse(o=>{
        if (!o.isMesh) return;
        if (overrideMat){
          const base = overrideMat.clone();
          base.wireframe = wire;
          o.material = base;
        } else {
          // no override -> ensure sane standard base but keep existing
          if (Array.isArray(o.material)) o.material = o.material.map(m => enhanceMaterial(m));
          else o.material = enhanceMaterial(o.material);
          o.material.wireframe = wire || o.material.wireframe;
        }
        o.material.needsUpdate = true;
      });
    }

    // ======= Light-only toggle =======
    function setLightOnly(root, on){
      if (!root) return;
      root.traverse(o=>{
        if (!o.isMesh) return;
        const mats = Array.isArray(o.material) ? o.material : [o.material];
        mats.forEach(m=>{
          if (!m) return;
          if (on){
            if (!savedOriginal.has(m)){
              savedOriginal.set(m, {
                color: m.color?.clone?.(),
                emissive: m.emissive?.clone?.(),
                map: m.map || null,
                emissiveMap: m.emissiveMap || null,
                roughness: m.roughness,
                metalness: m.metalness
              });
            }
            m.map = null;
            m.emissiveMap = null;
            m.color?.set?.(0xffffff);
            if ('roughness' in m) m.roughness = 0.6;
            if ('metalness' in m) m.metalness = 0.0;
            m.needsUpdate = true;
          } else {
            const saved = savedOriginal.get(m);
            if (saved){
              m.map = saved.map;
              m.emissiveMap = saved.emissiveMap;
              saved.color && m.color?.copy?.(saved.color);
              saved.emissive && m.emissive?.copy?.(saved.emissive);
              if ('roughness' in m && saved.roughness !== undefined) m.roughness = saved.roughness;
              if ('metalness' in m && saved.metalness !== undefined) m.metalness = saved.metalness;
              m.needsUpdate = true;
            }
          }
        });
      });
    }

    // ======= Camera framing =======
    function frameObject(obj){
      if (!obj) return;
      const box = new THREE.Box3().setFromObject(obj);
      const sphere = box.getBoundingSphere(new THREE.Sphere());
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const dist = sphere.radius / Math.sin(Math.min(Math.PI/4, fov/2));
      const dirTo = new THREE.Vector3(0, 0.2, 1).normalize();
      camera.position.copy(sphere.center.clone().addScaledVector(dirTo, dist*1.2));
      controls.target.copy(sphere.center);
      controls.update();
    }
    function resetCamera(){ frameObject(currentModel || scene); }

    // ======= Adaptive Grid =======
    let gridSize = 10, gridDiv = 20;
    function resizeGridToModel(root){
      if (!root) { createGrid(10, 20); gridSize=10; gridDiv=20; return; }
      const box = new THREE.Box3().setFromObject(root);
      const size = new THREE.Vector3();
      box.getSize(size);
      const radius = Math.max(size.x, size.z) * 0.6;
      // choose grid size as power-of-two-like nice value
      const nice = (v)=>{
        const p = Math.pow(2, Math.ceil(Math.log2(Math.max(1, v))));
        return Math.min(Math.max(10, p), 32768);
      };
      gridSize = nice(radius * 2);
      gridDiv = Math.min(200, Math.max(10, Math.round(gridSize/0.5)));
      createGrid(gridSize, gridDiv);
    }

    // ======= Scene tree =======
    function buildSceneTree(root){
      treeRoot.innerHTML = '';
      const ul = document.createElement('ul');
      treeRoot.appendChild(ul);
      function addNode(o, parent){
        const li = document.createElement('li');
        const btn = document.createElement('button');
        btn.textContent = o.name || o.type;
        btn.addEventListener('click', ()=> selectObject(o, btn));
        if (o === selectedObject) btn.classList.add('selected');
        li.appendChild(btn);
        parent.appendChild(li);
        if (o.children?.length){
          const ul2 = document.createElement('ul');
          li.appendChild(ul2);
          o.children.forEach(c=> addNode(c, ul2));
        }
      }
      (root || scene).children.forEach(o=> addNode(o, ul));
    }

    // ======= Selection =======
    function selectObject(obj, buttonEl){
      selectedObject = obj;
      outlinePass.selectedObjects = obj ? [obj] : [];
      document.querySelectorAll('#tree button').forEach(b=>b.classList.remove('selected'));
      if (buttonEl) buttonEl.classList.add('selected');
    }
    canvas.addEventListener('mousedown', (e)=>{
      if (e.button!==0) return;
      const rect = canvas.getBoundingClientRect();
      const ndc = new THREE.Vector2(
        ( (e.clientX-rect.left) / rect.width ) * 2 - 1,
        - ( (e.clientY-rect.top) / rect.height ) * 2 + 1
      );
      const ray = new THREE.Raycaster();
      ray.setFromCamera(ndc, camera);
      const meshes = [];
      if (currentModel){
        currentModel.traverse(o=>{ if (o.isMesh) meshes.push(o); });
      }else{
        scene.traverse(o=>{ if (o.isMesh) meshes.push(o); });
      }
      const hit = ray.intersectObjects(meshes, true)[0];
      if (hit){
        selectObject(hit.object);
        openInspector(true);
        buildSceneTree(currentModel);
      }
    });
    window.addEventListener('keydown', (e)=>{
      if (e.code==='KeyF' && selectedObject) {
        frameObject(selectedObject);
      } else if (e.code==='KeyR'){
        resetCamera();
      } else if (e.code==='Delete'){
        selectObject(null);
      }
    });

    // ======= Stats =======
    function updateStats(){
      let tris = 0; let objs = 0;
      scene.traverse(o=>{
        objs++;
        if (o.isMesh && o.geometry){
          const index = o.geometry.index;
          const pos = o.geometry.attributes.position;
          if (index) tris += index.count / 3;
          else if (pos) tris += pos.count / 3;
        }
      });
      polyCountEl.textContent = new Intl.NumberFormat('ru-RU').format(tris) + ' —Ç—Ä–∏—Å.';
      objCountEl.textContent = objs;
    }

    // ======= Overlay/progress =======
    function showOverlay(title, sub){
      overlay.classList.add('show');
      progressTitle.textContent = title || '–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶';
      progressSub.textContent = sub || '';
      setIndeterminate();
    }
    function hideOverlay(){ overlay.classList.remove('show'); }
    function setProgress(p){
      meter.classList.remove('indeterminate');
      meter.firstElementChild.style.width = Math.round(p*100)+'%';
      progressSub.textContent = Math.round(p*100) + '%';
    }
    function setIndeterminate(){
      meter.classList.add('indeterminate');
      meter.firstElementChild.style.width = '40%';
      progressSub.textContent = '–û–∂–∏–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ‚Ä¶';
    }

    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(()=> toastEl.classList.remove('show'), 2600);
    }

    // ======= HDRI / Background =======
    async function applyHDRI(url){
      if (!url) { scene.environment = null; updateBackgroundFromUI(); saveSettings(); return; }
      showOverlay('HDRI', '–ó–∞–≥—Ä—É–∂–∞–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ‚Ä¶');
      return new Promise((resolve, reject)=>{
        const loader = new RGBELoader();
        loader.load(url, (tex)=>{
          tex.mapping = THREE.EquirectangularReflectionMapping;
          envHdrTex && envHdrTex.dispose?.();
          envHdrTex = tex;
          scene.environment = tex;
          hideOverlay();
          saveSettings();
          resolve();
        }, undefined, (err)=>{ hideOverlay(); toast('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å HDRI'); reject(err); });
      });
    }
    function updateBackgroundFromUI(){
      const opt = bgSelect.value;
      if (opt === 'transparent'){
        scene.background = null;
        renderer.alpha = true;
      } else if (opt === 'lightgray'){
        scene.background = new THREE.Color(isDark()?0x1f2937:0xe5e7eb);
      } else if (opt === 'midgray'){
        scene.background = new THREE.Color(isDark()?0x111827:0x9ca3af);
      } else if (opt === 'darkgray'){
        scene.background = new THREE.Color(isDark()?0x0b0d12:0x374151);
      } else if (opt === 'white'){
        scene.background = new THREE.Color(isDark()?0x0b0d12:0xffffff);
      } else if (opt === 'custom'){
        scene.background = new THREE.Color(bgColor.value);
      }
      saveSettings();
    }
    bgSelect.addEventListener('change', ()=>{
      updateBackgroundFromUI();
    });
    bgColor.addEventListener('input', ()=>{
      bgSelect.value = 'custom';
      updateBackgroundFromUI();
    });

    // ======= Loaders: GLTF & FBX =======
    async function postLoad(root, animations){
      root.traverse(o=>{
        if (o.isMesh){
          o.castShadow = renderer.shadowMap.enabled;
          o.receiveShadow = renderer.shadowMap.enabled;
          if (Array.isArray(o.material)) {
            o.material = o.material.map(m => enhanceMaterial(m));
          } else {
            o.material = enhanceMaterial(o.material);
          }
        }
      });
      scene.add(root);
      currentModel = root;
      buildSceneTree(currentModel);
      frameObject(currentModel);
      updateStats();
      resizeGridToModel(currentModel);
      applyMaterialOverride(currentModel);
      if (toggleLightOnly.checked) setLightOnly(currentModel, true);

      setupAnimations(animations || []);
      hideOverlay();
    }

    function setupAnimations(clips){
      resetAnimationsUI();
      currentClips = clips;
      if (!currentClips.length) return;
      mixer = new THREE.AnimationMixer(currentModel);
      currentClips.forEach((clip, i)=>{
        const opt = document.createElement('option');
        opt.value = i; opt.textContent = clip.name || ('Clip ' + (i+1));
        animSelect.appendChild(opt);
      });
      animSelect.selectedIndex = 0;
      activeAction = mixer.clipAction(currentClips[0]);
      applyLoopAndSpeed();
      updateAnimTimeUI(0, currentClips[0].duration);
    }

    function resetAnimationsUI(){
      animSelect.innerHTML = '';
      currentClips = [];
      if (activeAction){ activeAction.stop(); activeAction = null; }
      if (mixer){ mixer.stopAllAction(); mixer.uncacheRoot(mixer.getRoot()); mixer = null; }
      animProgress.value = 0;
      animTime.textContent = '0.00 / 0.00s';
      animPlayPause.dataset.state = 'stopped';
      animPlayPause.textContent = i18n[langSelect.value].animPlay;
    }

    function playPause(){
      if (!mixer || !currentClips.length) return;
      if (!activeAction){
        activeAction = mixer.clipAction(currentClips[animSelect.selectedIndex]);
        applyLoopAndSpeed();
      }
      if (animPlayPause.dataset.state !== 'playing'){
        activeAction.paused = false;
        activeAction.play();
        animPlayPause.dataset.state = 'playing';
        animPlayPause.textContent = i18n[langSelect.value].animPause;
      } else {
        activeAction.paused = true;
        animPlayPause.dataset.state = 'paused';
        animPlayPause.textContent = i18n[langSelect.value].animPlay;
      }
      saveSettings();
    }
    function stopAnim(){
      if (!mixer) return;
      mixer.stopAllAction();
      if (activeAction){ activeAction.stop(); }
      activeAction = mixer.clipAction(currentClips[animSelect.selectedIndex] || currentClips[0]);
      applyLoopAndSpeed();
      animPlayPause.dataset.state = 'stopped';
      animPlayPause.textContent = i18n[langSelect.value].animPlay;
      updateAnimTimeUI(0, (activeAction? activeAction.getClip().duration : 0));
    }
    function applyLoopAndSpeed(){
      if (!activeAction) return;
      activeAction.setLoop(animLoop.checked ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
      const s = parseFloat(animSpeed.value) || 1;
      activeAction.setEffectiveTimeScale(s);
      activeAction.setEffectiveWeight(1);
      activeAction.paused = true; // default paused
      saveSettings();
    }

    animSelect.addEventListener('change', ()=>{
      if (!mixer || !currentClips.length) return;
      const wasPlaying = (animPlayPause.dataset.state === 'playing');
      mixer.stopAllAction();
      activeAction?.stop();
      activeAction = mixer.clipAction(currentClips[animSelect.selectedIndex]);
      applyLoopAndSpeed();
      updateAnimTimeUI(0, activeAction.getClip().duration);
      if (wasPlaying){ activeAction.play(); } else { animPlayPause.textContent = i18n[langSelect.value].animPlay; animPlayPause.dataset.state='stopped'; }
      saveSettings();
    });

    animPlayPause.addEventListener('click', playPause);
    animStop.addEventListener('click', stopAnim);
    animLoop.addEventListener('change', applyLoopAndSpeed);
    animSpeed.addEventListener('change', applyLoopAndSpeed);

    animProgress.addEventListener('input', ()=>{
      if (!activeAction || !mixer) return;
      const dur = activeAction.getClip().duration;
      const t = parseFloat(animProgress.value) * dur;
      activeAction.time = t;
      mixer.update(0);
      updateAnimTimeUI(t, dur);
    });
    function updateAnimTimeUI(time, dur){
      const clamp = (v)=> Math.max(0, Math.min(v, dur||0));
      const t = clamp(time); const d = dur || 0;
      animTime.textContent = `${t.toFixed(2)} / ${d.toFixed(2)}s`;
      animProgress.value = d ? (t / d) : 0;
    }

    // ======= Exposed =======
    window.clearCurrentModel = clearCurrentModel;
    window.openInspector = openInspector;

    function loadGLTF(file){
      clearCurrentModel();
      showOverlay('–ó–∞–≥—Ä—É–∑–∫–∞ glTF/GLB', file.name);
      loadWithURL(gltfLoader, file, (gltf)=>{
        postLoad(gltf.scene, gltf.animations || []);
      }, null, (err)=>{
        hideOverlay(); toast('–û—à–∏–±–∫–∞ GLTF: ' + err.message);
      });
    }
    function loadFBX(file){
      clearCurrentModel();
      showOverlay('–ó–∞–≥—Ä—É–∑–∫–∞ FBX', file.name);
      loadWithURL(fbxLoader, file, (obj)=>{
        postLoad(obj, obj.animations || []);
      }, null, (err)=>{
        hideOverlay(); toast('–û—à–∏–±–∫–∞ FBX: ' + err.message);
      });
    }
    window.loadGLTF = loadGLTF;
    window.loadFBX = loadFBX;

    // ======= UI actions =======
    langSelect.addEventListener('change', ()=> applyLang(langSelect.value));

    resetCameraBtn.addEventListener('click', resetCamera);
    clearSceneBtn.addEventListener('click', ()=>{ clearCurrentModel(); buildSceneTree(null); toast('–°—Ü–µ–Ω–∞ –æ—á–∏—â–µ–Ω–∞'); saveSettings(); });

    toggleShadows.addEventListener('change', ()=>{
      const on = toggleShadows.checked;
      renderer.shadowMap.enabled = on;
      dir.castShadow = on;
      currentModel?.traverse?.(o=>{
        if (o.isMesh) { o.castShadow = on; o.receiveShadow = on; }
      });
      saveSettings();
    });
    toggleFXAA.addEventListener('change', ()=>{
      fxaaPass.enabled = toggleFXAA.checked; saveSettings();
    });
    toggleLightOnly.addEventListener('change', ()=>{
      setLightOnly(currentModel, toggleLightOnly.checked); saveSettings();
    });
    toggleGrid.addEventListener('change', ()=>{
      grid.visible = !!toggleGrid.checked; saveSettings();
    });

    applyHdriBtn.addEventListener('click', ()=> applyHDRI(hdriUrlInput.value.trim()));

    matOverride.addEventListener('change', ()=>{ applyMaterialOverride(currentModel); saveSettings(); });
    toggleWireframe.addEventListener('change', ()=>{ applyMaterialOverride(currentModel); saveSettings(); });

    // ======= Resize =======
    function onResize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      composer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      outlinePass.setSize(w, h);
      fxaaPass.material.uniforms['resolution'].value.set(1/w, 1/h);
    }
    window.addEventListener('resize', onResize);

    // ======= Render loop =======
    let lastFpsUpdate = 0;
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      mixer?.update(dt);
      if (activeAction && animPlayPause.dataset.state === 'playing'){
        const dur = activeAction.getClip().duration;
        const t = activeAction.time % dur;
        updateAnimTimeUI(t, dur);
      }
      controls.update();
      composer.render();
      const tnow = performance.now();
      if (!lastFpsUpdate) lastFpsUpdate = tnow;
      if (tnow - lastFpsUpdate >= 500){
        const fps = (1/dt).toFixed(0);
        fpsEl.textContent = fps;
        lastFpsUpdate = tnow;
      }
    }
    animate();

    // ======= Init: restore settings =======
    (function initFromSettings(){
      const s = loadSettings();
      if (s.theme) setTheme(s.theme); else setTheme('light');
      if (s.lang){ langSelect.value = s.lang; }
      applyLang(langSelect.value);

      if (s.toggles){
        toggleShadows.checked = !!s.toggles.shadows;
        toggleFXAA.checked = s.toggles.fxaa !== false;
        toggleLightOnly.checked = !!s.toggles.lightonly;
        toggleGrid.checked = s.toggles.grid !== false;
      }
      if (s.background){
        bgSelect.value = s.background.mode || 'white';
        bgColor.value = s.background.color || '#ffffff';
        updateBackgroundFromUI();
      } else {
        updateBackgroundFromUI();
      }
      if (s.hdri){ hdriUrlInput.value = s.hdri; }
      if (s.material){
        matOverride.value = s.material.override || 'none';
        toggleWireframe.checked = !!s.material.wireframe;
      }
      if (s.anim){
        animLoop.checked = !!s.anim.loop;
        animSpeed.value = s.anim.speed || 1;
      }
      // Grid visibility already applied in createGrid
      saveSettings();
    })();

    // Helpers
    function getNumber(v, def){ v = Number(v); return Number.isFinite(v)?v:def; }
  </script>
</body>
</html>