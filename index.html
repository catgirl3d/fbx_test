<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX/GLTF Viewer with Modern UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #file-input-label, #reset-camera, .anim-btn {
            transition: all 0.3s ease;
        }
        #file-input-label:hover, #reset-camera:hover, .anim-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
        }
        #file-input {
            display: none;
        }
        #bg-color {
            transition: all 0.3s ease;
        }
        #bg-color:hover {
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        #progress {
            transition: opacity 0.3s ease;
        }
        /* Loading spinner inside progress text */
        #progress::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #34d399;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Stacking / z-index fixes to prevent panels from covering each other */
        /* Use fixed positioning for UI panels so z-index ordering is reliable across browsers.
           Make non-interactive indicators ignore pointer-events so they don't block clicks.
           Keep canvas behind UI but still receive pointer events for OrbitControls. */
    
        /* Renderer canvas (three.js) should fill viewport and sit at the back */
        canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
    
        /* File name - visible but non-interactive */
        #file-name {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 110;
            pointer-events: none;
        }
    
        /* Left-side controls must be the topmost interactive UI so buttons remain clickable */
        #left-controls {
            position: fixed;
            top: 4rem;
            left: 1rem;
            z-index: 1000; /* top-most interactive left controls */
            pointer-events: auto;
        }
    
        /* Animation controls should appear directly under left-controls (stacked) */
        #animation-controls {
            position: fixed;
            left: 1rem;
            z-index: 900; /* below left-controls */
            pointer-events: auto;
        }
    
        /* Progress indicator: positioned in bottom-left corner */
        #progress {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            pointer-events: none; /* indicators must not intercept clicks */
            z-index: 800;
            color: white; /* Ensure text is visible */
            background: rgba(31, 41, 55, 0.9); /* Darker background for better contrast */
        }
        
        /* Debug indicator: stacked below other controls */
        #debug {
            position: fixed;
            left: 1rem;
            pointer-events: none; /* indicators must not intercept clicks */
            z-index: 800; /* base value; precise stacking enforced in JS when positioning */
        }
    
        /* Make child inputs/buttons of progress/debug still non-interactive (these are just displays) */
        #progress *, #debug * {
            pointer-events: none;
        }
    
        /* Info panel (top-right) should not cover the animation controls */
        #info {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 700;
            pointer-events: auto;
        }
    
        /* Scene inspector stays below core controls but above indicators */
        #scene-inspector {
            position: fixed;
            top: 0;
            right: -320px; /* keep default closed position */
            z-index: 600;
            pointer-events: auto;
        }
    
        /* Ensure the inspector toggle remains clickable (always on top) */
        #inspector-toggle {
            z-index: 9999 !important;
            pointer-events: auto;
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #left-controls {
                top: 5rem;
                left: 0.5rem;
                width: auto;
                max-width: 150px;
            }
            
            #animation-controls {
                left: 0.5rem;
            }
            
            #progress {
                bottom: 0.5rem;
                left: 0.5rem;
            }
            
            #debug {
                left: 0.5rem;
            }
            
            #info {
                top: 0.5rem;
                right: 0.5rem;
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
            
            #file-name {
                top: 0.5rem;
                font-size: 0.875rem;
                padding: 0.25rem 0.5rem;
            }
            
            #inspector-toggle {
                top: 0.5rem;
                right: 0.5rem;
                padding: 0.25rem;
            }
            
            #scene-inspector {
                width: 100%;
                height: 70%;
                top: auto;
                bottom: 0;
                right: 0 !important;
                transition: bottom 0.3s ease-out;
            }
            
            #scene-inspector.open {
                bottom: 0 !important;
            }
            
            #scene-inspector.closed {
                bottom: -70%;
            }
        }
    </style>
</head>
<body class="bg-gray-200">
    <div id="file-name" class="absolute top-4 left-1/2 transform -translate-x-1/2 text-white text-xl font-bold bg-gray-800 bg-opacity-75 px-4 py-2 rounded-lg"></div>
    <div id="error" class="absolute top-16 left-4 text-red-500 text-lg"></div>
    <div id="info" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg">
        WSAD: Перемещение | Q/E: Вверх/Вниз | Мышь: Вращение/Масштаб
    </div>
    <div id="left-controls" class="absolute top-16 left-4 flex flex-col space-y-2 w-44">
        <label for="file-input" id="file-input-label" class="bg-green-500 text-white font-semibold py-2 px-3 rounded-lg cursor-pointer shadow-lg hover:bg-green-600 text-center block w-full">
            Выбрать файл
        </label>
        <input type="file" id="file-input" accept=".fbx,.gltf,.glb" class="hidden">
        <button id="reset-camera" class="bg-blue-500 text-white font-semibold py-2 px-3 rounded-lg cursor-pointer shadow-lg hover:bg-blue-600 w-full">
            Сбросить камеру
        </button>
        <select id="bg-color" class="bg-gray-800 text-white font-semibold py-2 px-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 w-full">
            <option value="#dddddd">Серый</option>
            <option value="#1e3a8a">Тёмно-синий</option>
            <option value="#000000">Чёрный</option>
            <option value="#ffffff">Белый</option>
        </select>
        <select id="display-mode" class="bg-gray-800 text-white font-semibold py-2 px-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 w-full">
            <option value="standard">Стандартный</option>
            <option value="wireframe">Каркасный</option>
            <option value="lighting">Только освещение</option>
        </select>
    </div>
    
    <!-- Элементы управления анимацией -->
    <div id="animation-controls" class="absolute left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden">
        <div class="mb-2">
            <select id="animation-select" class="bg-gray-700 text-white py-1 px-2 rounded text-sm">
                <option value="">Нет анимаций</option>
            </select>
        </div>
        <div class="flex items-center space-x-2 mb-2">
            <button id="play-pause-btn" class="anim-btn bg-green-600 hover:bg-green-700 px-2 py-1 rounded text-xs">
                ▶️ Играть
            </button>
            <button id="stop-btn" class="anim-btn bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-xs">
                ⏹️ Стоп
            </button>
            <input type="range" id="animation-slider" class="flex-1" min="0" max="100" value="0" step="0.1">
            <span id="duration-label" class="text-xs">0s</span>
        </div>
        <div class="flex items-center space-x-2 text-xs">
            <label>Скорость:</label>
            <input type="number" id="speed-input" class="w-12 bg-gray-700 text-white py-1 px-1 rounded text-xs" min="0.1" max="5" step="0.1" value="1">
            <label class="ml-2">
                <input type="checkbox" id="loop-checkbox" class="mr-1" checked>
                Зацикливать
            </label>
        </div>
    </div>
    <!-- Toggle button for inspector -->
    <button id="inspector-toggle" class="fixed top-4 right-4 z-[999] p-3 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5h12m-12 7h12m-12 7h12M1 5h12m-12 7h12m-12 7h12"/>
        </svg>
    </button>

    <!-- Scene inspector panel -->
    <div id="scene-inspector" class="fixed top-0 right-[-320px] h-full w-80 bg-gray-800 bg-opacity-95 text-white px-4 py-4 shadow-xl transition-all duration-300 ease-out overflow-y-auto z-40">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Инспектор сцены</h2>
            <button id="close-inspector" class="p-1 hover:bg-gray-700 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        <!-- Search input for filtering scene tree -->
        <div class="mb-4">
            <input type="text" id="scene-search" placeholder="Поиск объектов..." class="w-full px-3 py-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
        </div>
        <div id="scene-tree" class="text-sm mb-4 max-h-[60vh] overflow-auto border border-gray-600 rounded p-2 bg-gray-900"></div>
        <div id="object-properties" class="text-xs bg-gray-700 p-2 rounded max-h-60 overflow-auto">
            <h3 class="font-semibold mb-2">Свойства объекта</h3>
            <div id="properties-content">Выберите объект в дереве</div>
        </div>
    </div>

    
    <div id="progress" class="fixed bottom-1 left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden"></div>
    <div id="debug" class="absolute top-64 left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Postprocessing & outline (used for object highlighting) -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script> <!-- Added CopyShader.js -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    
    <style>
        /* Additional styles for left controls uniform width */
        #left-controls > * {
            min-width: 100%;
            box-sizing: border-box;
        }
    </style>

    <script>
        // Инициализация сцены
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
 
        // Post-processing (composer + outline)
        // composer and outlinePass are used to visually highlight selected objects
        let composer, outlinePass, effectFXAA;
        function setupPostProcessing() {
            try {
                composer = new THREE.EffectComposer(renderer);
                const renderPass = new THREE.RenderPass(scene, camera);
                composer.addPass(renderPass);
 
                outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
                outlinePass.edgeStrength = 5.0;
                outlinePass.edgeGlow = 0.5;
                outlinePass.edgeThickness = 1.0;
                outlinePass.visibleEdgeColor.set('#ffffff');
                outlinePass.hiddenEdgeColor.set('#2563eb');
                outlinePass.pulsePeriod = 0; // no pulsing by default
                composer.addPass(outlinePass);
 
                // FXAA for crisper edges (optional)
                effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
                effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
                effectFXAA.renderToScreen = true;
                composer.addPass(effectFXAA);
                console.log('Post-processing initialized (composer, outlinePass, FXAA).');
            } catch (err) {
                console.error('Error initializing post-processing:', err);
                composer = null;
                outlinePass = null;
            }
        }
        setupPostProcessing();
 
        // Улучшенное освещение
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Управление камерой
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();

        // Храним текущую модель и анимацию
        let currentModel = null;
        let mixer = null;
        let animations = [];
        let currentAction = null;
        let clock = new THREE.Clock();
        let isPlaying = false;
        let animationDuration = 0;
        let isSliderDragging = false;

        // Элементы управления анимацией
        const animationControls = document.getElementById('animation-controls');
        const animationSelect = document.getElementById('animation-select');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const animationSlider = document.getElementById('animation-slider');
        const durationLabel = document.getElementById('duration-label');
        const speedInput = document.getElementById('speed-input');
        const loopCheckbox = document.getElementById('loop-checkbox');

        // Left controls reference (used to avoid spatial overlap)
        const leftControls = document.getElementById('left-controls');

        // Ensure animation-controls are positioned so they never cover the left-controls.
        // We position animationControls fixed relative to leftControls and adjust to avoid overlap.
        function positionAnimationControls() {
            if (!leftControls || !animationControls) return;
    
            // measure in viewport coordinates
            const leftRect = leftControls.getBoundingClientRect();
    
            // Prepare animationControls for measurement
            animationControls.style.position = 'fixed';
            animationControls.style.minWidth = `${leftRect.width}px`;
            animationControls.style.left = `${Math.max(8, leftRect.left)}px`;
            animationControls.style.top = `${leftRect.bottom + 8}px`;
    
            // small helper to test intersection
            function rectsIntersect(a, b) {
                return !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);
            }
    
            // Re-measure after applying initial placement
            let animRect = animationControls.getBoundingClientRect();
    
            // If the animation panel still intersects leftControls (very rare) try placing it to the right
            if (rectsIntersect(animRect, leftRect)) {
                const rightX = leftRect.right + 8;
                animationControls.style.left = `${rightX}px`;
                // Align top with leftControls if there's space, otherwise keep below
                animationControls.style.top = `${leftRect.top}px`;
                animRect = animationControls.getBoundingClientRect();
            }
    
            // If the panel is off-screen to the right, shift it left so it's visible
            if (animRect.right > window.innerWidth - 8) {
                const shiftLeft = Math.max(8, window.innerWidth - animRect.width - 8);
                animationControls.style.left = `${shiftLeft}px`;
                animRect = animationControls.getBoundingClientRect();
            }
    
            // If the panel goes off the bottom of the viewport, try to place it above the leftControls
            if (animRect.bottom > window.innerHeight - 8) {
                const aboveTop = Math.max(8, leftRect.top - animRect.height - 8);
                animationControls.style.top = `${aboveTop}px`;
                animRect = animationControls.getBoundingClientRect();
            }
    
            // Final guard: ensure the animation panel does not cover the top-left buttons vertically;
            // if it still overlaps, reduce its top to sit below leftControls bottom.
            if (rectsIntersect(animationControls.getBoundingClientRect(), leftRect)) {
                animationControls.style.top = `${leftRect.bottom + 8}px`;
            }
        }
    
        // Reposition responsively and when left-controls change
        window.addEventListener('resize', positionAnimationControls);
        if (leftControls) {
            const mo = new MutationObserver(positionAnimationControls);
            mo.observe(leftControls, { attributes: true, childList: true, subtree: true, characterData: true });
        }
    
        // Initial positioning (defer to allow initial rendering)
        setTimeout(positionAnimationControls, 50);
    
        // Position progress/debug indicators so they appear sequentially (below animation panel or left-controls)
        const progressDiv = document.getElementById('progress');
        const debugDiv = document.getElementById('debug');
    
        function positionIndicators() {
                    if (!leftControls || !animationControls || !debugDiv) return;
            
                    const leftRect = leftControls.getBoundingClientRect();
                    const leftX = Math.max(8, leftRect.left);
                    const leftWidth = Math.max(120, leftRect.width);
            
                    // Decide baseTop: if animation-controls visible, place debug below it; otherwise below leftControls
                    let baseTop;
                    if (!animationControls.classList.contains('hidden')) {
                        const animRect = animationControls.getBoundingClientRect();
                        // If animation controls have zero height (not rendered) treat as hidden
                        if (animRect.height > 0) {
                            baseTop = animRect.bottom + 8;
                        } else {
                            baseTop = leftRect.bottom + 8;
                        }
                    } else {
                        baseTop = leftRect.bottom + 8;
                    }
            
                    // Position debug (progress is now fixed in bottom-left via CSS)
                    debugDiv.style.position = 'fixed';
                    debugDiv.style.left = `${leftX}px`;
                    debugDiv.style.top = `${baseTop}px`;
                    debugDiv.style.minWidth = `${leftWidth}px`;
                    debugDiv.style.zIndex = '790';
                    debugDiv.style.pointerEvents = 'none';
            
                    // If debug runs off-screen to the right, shift it left
                    const finalDebugRect = debugDiv.getBoundingClientRect();
                    if (finalDebugRect.right > window.innerWidth - 8) {
                        const shiftLeft = Math.max(8, window.innerWidth - finalDebugRect.width - 8);
                        debugDiv.style.left = `${shiftLeft}px`;
                    }
                }
            
                // Reposition indicators on resize and when UI changes
                window.addEventListener('resize', positionIndicators);
                const indicatorObserver = new MutationObserver(positionIndicators);
                if (leftControls) indicatorObserver.observe(leftControls, { attributes: true, childList: true, subtree: true, characterData: true });
                if (animationControls) indicatorObserver.observe(animationControls, { attributes: true, childList: true, subtree: true, characterData: true });
                if (debugDiv) indicatorObserver.observe(debugDiv, { attributes: true, attributeFilter: ['class', 'style'] });
            
                // initial indicator placement
                setTimeout(positionIndicators, 60);

        // Функция обновления списка анимаций
        function updateAnimationList() {
            animationSelect.innerHTML = '<option value="">Нет анимаций</option>';
            
            if (animations.length > 0) {
                    animations.forEach((clip, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${clip.name || `Анимация ${index + 1}`} (${clip.duration.toFixed(1)}s)`;
                        animationSelect.appendChild(option);
                    });
                    animationControls.classList.remove('hidden');
        
                    // Recalculate and enforce safe placement so animation panel doesn't overlap left controls
                    // small defer to allow browser to update layout
                    setTimeout(() => {
                        if (typeof positionAnimationControls === 'function') {
                            positionAnimationControls();
                        }
                        // Also reposition indicators so they stack after the animation panel
                        if (typeof positionIndicators === 'function') {
                            positionIndicators();
                        }
                    }, 20);
                } else {
                    animationControls.classList.add('hidden');
                    // Ensure debug indicator repositions when animation panel hides
                    if (typeof positionIndicators === 'function') {
                        setTimeout(positionIndicators, 10);
                    }
                }
        }

        // Функция воспроизведения анимации
        function playAnimation(index) {
            if (!mixer || !animations[index]) {
                console.warn('Нет mixer или анимации');
                return;
            }

            // Остановка предыдущей анимации
            if (currentAction) {
                currentAction.stop();
                currentAction = null;
            }
            
            const clip = animations[index];
            currentAction = mixer.clipAction(clip);
            animationDuration = clip.duration;
            
            // Настройка циклов
            if (loopCheckbox.checked) {
                currentAction.setLoop(THREE.LoopRepeat, Infinity);
            } else {
                currentAction.setLoop(THREE.LoopOnce);
                currentAction.clampWhenFinished = true;
            }
            
            // Установка скорости и запуск
            currentAction.timeScale = parseFloat(speedInput.value) || 1;
            currentAction.reset();
            currentAction.play();
            
            isPlaying = true;
            playPauseBtn.textContent = '⏸️ Пауза';
            
            // Настройка слайдера
            animationSlider.max = animationDuration;
            animationSlider.value = 0;
            durationLabel.textContent = `${animationDuration.toFixed(1)}s`;
            
            console.log(`Запуск анимации: ${clip.name}, длительность: ${animationDuration}s`);
        }

        function stopAnimation() {
            if (currentAction) {
                currentAction.stop();
                currentAction.reset();
                currentAction = null;
            }
            isPlaying = false;
            playPauseBtn.textContent = '▶️ Играть';
            animationSlider.value = 0;
        }

        // Обработчики событий анимации
        animationSelect.addEventListener('change', (event) => {
            if (event.target.value !== '') {
                playAnimation(parseInt(event.target.value));
            } else {
                stopAnimation();
            }
        });

        playPauseBtn.addEventListener('click', () => {
            if (!currentAction) {
                // Если нет текущей анимации, попробовать запустить первую доступную
                if (animations.length > 0) {
                    animationSelect.value = 0;
                    playAnimation(0);
                }
                return;
            }
            
            if (isPlaying) {
                currentAction.paused = true;
                isPlaying = false;
                playPauseBtn.textContent = '▶️ Играть';
            } else {
                currentAction.paused = false;
                isPlaying = true;
                playPauseBtn.textContent = '⏸️ Пауза';
            }
        });

        stopBtn.addEventListener('click', () => {
            stopAnimation();
        });

        // Обработка слайдера времени
        animationSlider.addEventListener('mousedown', () => {
            isSliderDragging = true;
        });

        animationSlider.addEventListener('mouseup', () => {
            isSliderDragging = false;
        });

        animationSlider.addEventListener('input', (event) => {
            if (currentAction && animationDuration > 0) {
                const time = parseFloat(event.target.value);
                currentAction.time = time;
                if (mixer) {
                    mixer.setTime(time);
                }
            }
        });

        speedInput.addEventListener('input', (event) => {
            if (currentAction) {
                const speed = parseFloat(event.target.value) || 1;
                currentAction.timeScale = speed;
            }
        });

        loopCheckbox.addEventListener('change', (event) => {
            if (currentAction) {
                if (event.target.checked) {
                    currentAction.setLoop(THREE.LoopRepeat, Infinity);
                } else {
                    currentAction.setLoop(THREE.LoopOnce);
                    currentAction.clampWhenFinished = true;
                }
            }
        });

        // Fallback textures for missing maps
        const fallbackTextures = {
            diffuse: null,
            normal: null,
            roughness: null,
            metalness: null,
            specular: null
        };

        // Create fallback textures
        function createFallbackTextures() {
            // Create a simple 1x1 white texture for diffuse
            const whiteTexture = new THREE.DataTexture(new Uint8Array([255, 255, 255]), 1, 1, THREE.RGBFormat);
            whiteTexture.needsUpdate = true;
            fallbackTextures.diffuse = whiteTexture;

            // Create a simple 1x1 gray texture for roughness (middle gray = 0.5)
            const grayTexture = new THREE.DataTexture(new Uint8Array([128, 128, 128]), 1, 1, THREE.RGBFormat);
            grayTexture.needsUpdate = true;
            fallbackTextures.roughness = grayTexture;

            // Create a simple 1x1 black texture for metalness
            const blackTexture = new THREE.DataTexture(new Uint8Array([0, 0, 0]), 1, 1, THREE.RGBFormat);
            blackTexture.needsUpdate = true;
            fallbackTextures.metalness = blackTexture;

            // Create a simple 1x1 neutral normal map (forward vector)
            const neutralNormal = new THREE.DataTexture(new Uint8Array([128, 128, 255]), 1, 1, THREE.RGBFormat);
            neutralNormal.needsUpdate = true;
            fallbackTextures.normal = neutralNormal;
        }

        // Initialize fallback textures
        createFallbackTextures();

        // Enhanced material function with PBR support
        function enhanceMaterial(material) {
            // Convert to MeshStandardMaterial for PBR support if not already
            if (!(material instanceof THREE.MeshStandardMaterial)) {
                const newMaterial = new THREE.MeshStandardMaterial();
                
                // Copy basic properties
                newMaterial.name = material.name;
                newMaterial.color = material.color || new THREE.Color(0xcccccc);
                newMaterial.opacity = material.opacity !== undefined ? material.opacity : 1;
                newMaterial.transparent = material.transparent || false;
                newMaterial.side = material.side || THREE.FrontSide;
                newMaterial.visible = material.visible;
                newMaterial.wireframe = material.wireframe;
                
                // Handle diffuse map
                if (material.map) {
                    newMaterial.map = material.map;
                }
                
                // Try to extract PBR properties from the original material
                // FBX materials might have these properties
                if (material.specularMap) {
                    // In FBX, specular maps might be used for metalness
                    newMaterial.metalnessMap = material.specularMap;
                    newMaterial.metalness = 1.0;
                }
                
                // Set default PBR values if not specified
                if (newMaterial.metalness === undefined) {
                    newMaterial.metalness = 0.0;
                }
                
                if (newMaterial.roughness === undefined) {
                    newMaterial.roughness = 0.5;
                }
                
                // Replace the material
                material = newMaterial;
            }
            
            // Ensure all required maps are present
            if (!material.map) {
                material.map = fallbackTextures.diffuse;
            }
            
            // Set fallback textures for PBR maps if not present
            if (!material.roughnessMap) {
                // Try to derive roughness from shininess if available
                if (material.shininess !== undefined) {
                    material.roughness = Math.pow(1.0 - Math.min(1.0, material.shininess / 1000), 2);
                }
                material.roughnessMap = fallbackTextures.roughness;
            }
            
            if (!material.metalnessMap) {
                material.metalnessMap = fallbackTextures.metalness;
            }
            
            if (!material.normalMap) {
                material.normalMap = fallbackTextures.normal;
            }
            
            // Handle transparency
            if (material.opacity < 1.0 || material.transparent) {
                material.transparent = true;
                // For better transparency handling
                if (material.alphaTest === undefined) {
                    material.alphaTest = 0.01;
                }
            }
            
            // Handle double-sided materials
            if (material.side === THREE.DoubleSide) {
                material.side = THREE.DoubleSide;
            } else {
                // Check if material should be double-sided based on properties
                // This is a heuristic - materials with transparency are often double-sided
                if (material.opacity < 1.0) {
                    material.side = THREE.DoubleSide;
                }
            }
            
            // Enable material updates
            material.needsUpdate = true;
            
            return material;
        }
        // Функция загрузки FBX
        function loadFBX(file, fileName) {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            // Очистка анимации
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            animations = [];
            stopAnimation();
            
            const progressDiv = document.getElementById('progress');
            const debugDiv = document.getElementById('debug');
            progressDiv.classList.remove('hidden');
            debugDiv.classList.add('hidden');
            animationControls.classList.add('hidden');
            // Position debug indicator (progress is now fixed in bottom-left)
            if (typeof positionIndicators === 'function') {
                setTimeout(positionIndicators, 20);
            }
            
            const loader = new THREE.FBXLoader();
            
            // Configure loader to handle textures properly
            loader.setPath('');
            loader.load(
                file,
                (fbx) => {
                    let meshCount = 0;
                    let materialCount = 0;
                    
                    fbx.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.material) {
                                materialCount++;
                                // Улучшение материалов с поддержкой PBR
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        enhanceMaterial(mat);
                                    });
                                } else {
                                    enhanceMaterial(child.material);
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Инициализация анимации
                    if (fbx.animations && fbx.animations.length > 0) {
                        console.log(`Найдено анимаций: ${fbx.animations.length}`);
                        fbx.animations.forEach((clip, i) => {
                            console.log(`Анимация ${i}: ${clip.name}, длительность: ${clip.duration}s`);
                        });
                        
                        mixer = new THREE.AnimationMixer(fbx);
                        animations = fbx.animations;
                    }
                    
                    console.log(`Модель ${fileName}: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`);
                    debugDiv.innerText = `Модель: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`;
                    debugDiv.classList.remove('hidden');
                    
                    if (meshCount === 0) {
                        document.getElementById('error').innerText = `Модель ${fileName} загружена, но не содержит видимой геометрии.`;
                        const placeholder = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({ color: 0xff0000 })
                        );
                        scene.add(placeholder);
                        currentModel = placeholder;
                    } else {
                        // Центрирование и масштабирование модели
                        const box = new THREE.Box3().setFromObject(fbx);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 1;
                        const scale = 2 / maxDim;
                        
                        fbx.scale.setScalar(scale);
                        fbx.position.copy(center.multiplyScalar(-scale));
                        
                        scene.add(fbx);
                        currentModel = fbx;
                        
                        // Настройка камеры
                        controls.target.set(0, 0, 0);
                        camera.position.set(
                            size.x * scale,
                            size.y * scale,
                            size.z * scale * 2
                        );
                        controls.update();
                        document.getElementById('error').innerText = '';
                    }
                    
                    updateAnimationList();
                    progressDiv.classList.add('hidden');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(2);
                        progressDiv.innerText = `Загрузка: ${percent}%`;
                    } else {
                        progressDiv.innerText = `Загрузка: ${(progress.loaded / 1024 / 1024).toFixed(2)} MB`;
                    }
                },
                (error) => {
                    console.error(`Ошибка загрузки ${fileName}:`, error);
                    document.getElementById('error').innerText = `Ошибка загрузки ${fileName}: ${error.message}`;
                    progressDiv.classList.add('hidden');
                    debugDiv.classList.add('hidden');
                }
            );
        }

        // Функция загрузки GLTF/GLB
        function loadGLTF(file, fileName) {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            // Очистка анимации
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            animations = [];
            stopAnimation();
            
            const progressDiv = document.getElementById('progress');
            const debugDiv = document.getElementById('debug');
            progressDiv.classList.remove('hidden');
            debugDiv.classList.add('hidden');
            animationControls.classList.add('hidden');
            // Position debug indicator (progress is now fixed in bottom-left)
            if (typeof positionIndicators === 'function') {
                setTimeout(positionIndicators, 20);
            }
            
            const loader = new THREE.GLTFLoader();
            loader.load(
                file,
                (gltf) => {
                    let meshCount = 0;
                    let materialCount = 0;
                    
                    gltf.scene.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.material) {
                                materialCount++;
                                // Улучшение материалов с поддержкой PBR
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        enhanceMaterial(mat);
                                    });
                                } else {
                                    enhanceMaterial(child.material);
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Инициализация анимации
                    if (gltf.animations && gltf.animations.length > 0) {
                        console.log(`Найдено анимаций: ${gltf.animations.length}`);
                        gltf.animations.forEach((clip, i) => {
                            console.log(`Анимация ${i}: ${clip.name}, длительность: ${clip.duration}s`);
                        });
                        
                        mixer = new THREE.AnimationMixer(gltf.scene);
                        animations = gltf.animations;
                    }
                    
                    console.log(`Модель ${fileName}: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`);
                    debugDiv.innerText = `Модель: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`;
                    debugDiv.classList.remove('hidden');
                    
                    if (meshCount === 0) {
                        document.getElementById('error').innerText = `Модель ${fileName} загружена, но не содержит видимой геометрии.`;
                        const placeholder = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({ color: 0xff0000 })
                        );
                        scene.add(placeholder);
                        currentModel = placeholder;
                    } else {
                        // Центрирование и масштабирование модели
                        const box = new THREE.Box3().setFromObject(gltf.scene);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 1;
                        const scale = 2 / maxDim;
                        
                        gltf.scene.scale.setScalar(scale);
                        gltf.scene.position.copy(center.multiplyScalar(-scale));
                        
                        scene.add(gltf.scene);
                        currentModel = gltf.scene;
                        
                        // Настройка камеры
                        controls.target.set(0, 0, 0);
                        camera.position.set(
                            size.x * scale,
                            size.y * scale,
                            size.z * scale * 2
                        );
                        controls.update();
                        document.getElementById('error').innerText = '';
                    }
                    
                    updateAnimationList();
                    progressDiv.classList.add('hidden');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(2);
                        progressDiv.innerText = `Загрузка: ${percent}%`;
                    } else {
                        progressDiv.innerText = `Загрузка: ${(progress.loaded / 1024 / 1024).toFixed(2)} MB`;
                    }
                },
                (error) => {
                    console.error(`Ошибка загрузки ${fileName}:`, error);
                    document.getElementById('error').innerText = `Ошибка загрузки ${fileName}: ${error.message}`;
                    progressDiv.classList.add('hidden');
                    debugDiv.classList.add('hidden');
                }
            );
        }

        // Обработка выбора файла
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('file-name').innerText = `Файл: ${file.name}`;
                const extension = file.name.split('.').pop().toLowerCase();
                console.log(`Выбранный файл: ${file.name}, расширение: ${extension}`);
                const url = URL.createObjectURL(file);
                
                if (extension === 'fbx') {
                    loadFBX(url, file.name);
                } else if (extension === 'gltf' || extension === 'glb') {
                    loadGLTF(url, file.name);
                } else {
                    document.getElementById('error').innerText = 'Поддерживаются только .fbx, .gltf, .glb';
                    document.getElementById('file-name').innerText = '';
                    document.getElementById('progress').classList.add('hidden');
                    document.getElementById('debug').classList.add('hidden');
                }
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }
        });

        // Сброс камеры
        document.getElementById('reset-camera').addEventListener('click', () => {
            camera.position.set(0, 0, 5);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        // Выбор цвета фона
        const bgColorSelect = document.getElementById('bg-color');
        bgColorSelect.addEventListener('change', (event) => {
            scene.background = new THREE.Color(event.target.value);
        });

        // Управление клавишами WSAD + Q/E
        const keys = { w: false, s: false, a: false, d: false, q: false, e: false };
        const moveSpeed = 0.1;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
                case 'KeyQ': keys.q = true; break;
                case 'KeyE': keys.e = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
                case 'KeyQ': keys.q = false; break;
                case 'KeyE': keys.e = false; break;
            }
        });

        // Основной цикл анимации
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Обновление анимации
            if (mixer && isPlaying) {
                mixer.update(delta);
                
                // Обновление слайдера времени (только если пользователь не перетаскивает)
                if (currentAction && !isSliderDragging) {
                    animationSlider.value = currentAction.time;
                    
                    // Проверка окончания анимации (для неповторяющихся)
                    if (!loopCheckbox.checked && currentAction.time >= animationDuration) {
                        isPlaying = false;
                        playPauseBtn.textContent = '▶️ Играть';
                    }
                }
            }
            
            // Управление камерой клавишами
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
            
            if (keys.w) {
                camera.position.addScaledVector(direction, moveSpeed);
                controls.target.addScaledVector(direction, moveSpeed);
            }
            if (keys.s) {
                camera.position.addScaledVector(direction, -moveSpeed);
                controls.target.addScaledVector(direction, -moveSpeed);
            }
            if (keys.a) {
                camera.position.addScaledVector(right, -moveSpeed);
                controls.target.addScaledVector(right, -moveSpeed);
            }
            if (keys.d) {
                camera.position.addScaledVector(right, moveSpeed);
                controls.target.addScaledVector(right, moveSpeed);
            }
            if (keys.q) {
                camera.position.y += moveSpeed;
                controls.target.y += moveSpeed;
            }
            if (keys.e) {
                camera.position.y -= moveSpeed;
                controls.target.y -= moveSpeed;
            }
            
            controls.update();
            if (typeof composer !== 'undefined' && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        animate();

        // Адаптация к размеру окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (typeof composer !== 'undefined' && composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            if (typeof effectFXAA !== 'undefined' && effectFXAA && effectFXAA.uniforms && effectFXAA.uniforms['resolution']) {
                effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            }
        });
    
        // --- Scene Inspector and Display Mode Switching ---
        // Toggle inspector panel for mobile responsiveness
        const inspectorToggleBtn = document.getElementById('inspector-toggle');
        const sceneInspector = document.getElementById('scene-inspector');

        inspectorToggleBtn.addEventListener('click', () => {
            if (sceneInspector.classList.contains('closed')) {
                sceneInspector.classList.remove('closed');
                sceneInspector.classList.add('open');
            } else {
                sceneInspector.classList.remove('open');
                sceneInspector.classList.add('closed');
            }
        });
    
        const sceneTreeDiv = document.getElementById('scene-tree');
        const propertiesContentDiv = document.getElementById('properties-content');
        const displayModeSelect = document.getElementById('display-mode');
        
        // Inspector panel elements
        const inspector = document.getElementById('scene-inspector');
        const toggleBtn = document.getElementById('inspector-toggle');
        const closeBtn = document.getElementById('close-inspector');

        // Debug initial state
        console.log('Inspector element:', inspector);
        console.log('Toggle button:', toggleBtn);
        console.log('Close button:', closeBtn);

        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Toggle classes (for Tailwind) and also enforce inline right to ensure the panel becomes visible.
            const opening = !inspector.classList.contains('right-0');
            inspector.classList.toggle('right-0');
            inspector.classList.toggle('right-[-320px]');
    
            if (opening) {
                // Force inline style so animation works even without Tailwind JIT class support
                inspector.style.right = '0px';
    
                // Build / refresh inspector contents shortly after opening
                setTimeout(() => {
                    try {
                        console.log('Inspector opened — currentModel:', currentModel);
    
                        // Ensure scene tree exists and is up-to-date
                        if (typeof buildSceneTree === 'function') {
                            buildSceneTree();
                        }
    
                        // If still empty, show an explicit message
                        if (sceneTreeDiv && sceneTreeDiv.innerHTML.trim() === '') {
                            sceneTreeDiv.innerHTML = currentModel ? '<p>Модель загружена, но дерево пустое.</p>' : '<p>Модель не загружена</p>';
                        }
    
                        // Populate properties pane with root model properties if available
                        if (currentModel && typeof showProperties === 'function') {
                            showProperties(currentModel);
                        } else if (propertiesContentDiv && propertiesContentDiv.innerHTML.trim() === '') {
                            propertiesContentDiv.innerHTML = 'Выберите объект в дереве';
                        }
                    } catch (err) {
                        console.error('Error while populating inspector on open:', err);
                        if (sceneTreeDiv && sceneTreeDiv.innerHTML.trim() === '') {
                            sceneTreeDiv.innerHTML = '<p>Ошибка при формировании дерева. Проверьте консоль.</p>';
                        }
                    }
                }, 60);
            } else {
                // closing: set inline right back to closed position
                inspector.style.right = '-320px';
            }
    
            console.log('Inspector toggled. open=', opening, ' inline right=', inspector.style.right);
        });

        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            inspector.classList.remove('right-0');
            inspector.classList.add('right-[-320px]');
        });

        document.addEventListener('click', (event) => {
            if (!inspector.contains(event.target) && !toggleBtn.contains(event.target)) {
                inspector.classList.remove('right-0');
                inspector.classList.add('right-[-320px]');
            }
        });
        // Add event listener for search input
        const sceneSearchInput = document.getElementById('scene-search');
        let searchTimeout = null;
        
        sceneSearchInput.addEventListener('input', (e) => {
            // Debounce search to avoid excessive filtering
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const searchTerm = e.target.value.toLowerCase();
                buildSceneTree(searchTerm);
            }, 300);
        });

        inspector.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    
        // Helper function to create tree item elements recursively
        function createTreeItem(object, searchTerm = '') {
            const item = document.createElement('div');
            item.style.paddingLeft = '12px';
            item.style.cursor = 'pointer';
            item.textContent = object.name || object.type;
    
            // Check if this item matches the search term
            const objectName = (object.name || object.type || '').toLowerCase();
            const matchesSearch = searchTerm === '' || objectName.includes(searchTerm);
    
            // Visibility toggle checkbox
            const visibilityCheckbox = document.createElement('input');
            visibilityCheckbox.type = 'checkbox';
            visibilityCheckbox.checked = object.visible;
            visibilityCheckbox.style.marginRight = '6px';
    
            visibilityCheckbox.addEventListener('click', (event) => {
                event.stopPropagation();
                object.visible = visibilityCheckbox.checked;
            });
    
            item.prepend(visibilityCheckbox);
    
            // Expand/collapse children if any
            let hasVisibleChildren = false;
            if (object.children && object.children.length > 0) {
                const expandBtn = document.createElement('span');
                expandBtn.textContent = '▶';
                expandBtn.style.display = 'inline-block';
                expandBtn.style.width = '12px';
                expandBtn.style.userSelect = 'none';
                expandBtn.style.marginRight = '4px';
                expandBtn.style.cursor = 'pointer';
    
                let expanded = false;
                const childrenContainer = document.createElement('div');
                childrenContainer.style.display = 'none';
    
                expandBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    expanded = !expanded;
                    childrenContainer.style.display = expanded ? 'block' : 'none';
                    expandBtn.textContent = expanded ? '▼' : '▶';
                });
    
                item.prepend(expandBtn);
    
                // Create children items
                object.children.forEach(child => {
                    const childItem = createTreeItem(child, searchTerm);
                    // Check if child item should be visible
                    if (childItem.style.display !== 'none') {
                        childrenContainer.appendChild(childItem);
                        hasVisibleChildren = true;
                    }
                });
    
                item.appendChild(childrenContainer);
            }
    
            // Hide item if it doesn't match search and has no visible children
            if (!matchesSearch && !hasVisibleChildren) {
                item.style.display = 'none';
            }
    
            // Add placeholder for alignment if no children
            if (!object.children || object.children.length === 0) {
                const placeholderSpan = document.createElement('span');
                placeholderSpan.style.display = 'inline-block';
                placeholderSpan.style.width = '16px';
                item.prepend(placeholderSpan);
            }
    
            // Selection handling
            item.addEventListener('click', (event) => {
                event.stopPropagation();
                selectObject(object, item);
            });
    
            return item;
        }
    
        let selectedItem = null;
        let selectedObject = null;
        // Track currently highlighted meshes when OutlinePass is not available (fallback)
        let highlightedMeshes = [];
 
        // Raycaster & pointer for clicking in the scene to select objects
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
 
        renderer.domElement.addEventListener('pointerdown', (event) => {
            // Ignore clicks if the inspector or UI handled the event (simple guard)
            // Use canvas bounding rect to correctly map pointer when canvas is resized or scaled
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const root = currentModel || scene;
            const targets = (root && root.children) ? root.children : scene.children;
            const intersects = raycaster.intersectObjects(targets, true);
            if (intersects.length > 0) {
                // Pick the first (closest) mesh
                const intersectedObject = intersects[0].object;
                selectObject(intersectedObject, null);
            } else {
                // Clear selection
                selectObject(null, null);
            }
        });
    
        function selectObject(object, itemElement) {
            // Clear previous tree selection highlight (if any)
            if (selectedItem) {
                try { selectedItem.style.backgroundColor = ''; } catch(e) {}
            }
 
            // Apply tree highlight if an item element is provided
            if (itemElement) {
                selectedItem = itemElement;
                try { selectedItem.style.backgroundColor = '#2563eb'; } catch(e) {}
            } else {
                selectedItem = null;
            }
 
            // Clear any previous fallback highlights
            if (highlightedMeshes && highlightedMeshes.length > 0) {
                highlightedMeshes.forEach(m => {
                    try {
                        if (m.userData && m.userData._origEmissiveHex !== undefined && m.material && 'emissive' in m.material) {
                            m.material.emissive.setHex(m.userData._origEmissiveHex);
                            delete m.userData._origEmissiveHex;
                        }
                    } catch (e) {}
                });
                highlightedMeshes = [];
            }
 
            selectedObject = object;
            console.log('Selection changed:', object, 'outlinePass present=', !!outlinePass);
 
            // Update outlinePass selection (use meshes contained in the selected object)
            if (typeof outlinePass !== 'undefined' && outlinePass) {
                if (!object) {
                    outlinePass.selectedObjects = [];
                } else {
                    const selection = [];
                    if (object.isMesh) {
                        selection.push(object);
                    } else {
                        // collect meshes under the object
                        object.traverse((c) => {
                            if (c.isMesh) selection.push(c);
                        });
                    }
                    outlinePass.selectedObjects = selection;
                }
            } else {
                // Fallback: if OutlinePass isn't available, tint emissive on meshes to indicate selection
                if (object) {
                    const meshes = [];
                    if (object.isMesh) meshes.push(object);
                    else object.traverse((c) => { if (c.isMesh) meshes.push(c); });
                    meshes.forEach(m => {
                        try {
                            if (m.material && 'emissive' in m.material) {
                                // store original emissive color (as hex) so we can restore later
                                m.userData._origEmissiveHex = m.material.emissive.getHex();
                                m.material.emissive.setHex(0x44a3ff); // light blue emissive
                                highlightedMeshes.push(m);
                            }
                        } catch (e) {}
                    });
                }
            }
 
            // Show properties in the inspector
            showProperties(object);
        }
    
        function showProperties(object) {
            if (!object) {
                propertiesContentDiv.innerHTML = 'Выберите объект в дереве';
                return;
            }
            let html = `<p><strong>Имя:</strong> ${object.name || '(без имени)'}</p>`;
            html += `<p><strong>Тип:</strong> ${object.type}</p>`;
            if (object.isMesh) {
                html += `<p><strong>Вершин:</strong> ${object.geometry?.attributes?.position?.count || 'N/A'}</p>`;
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        html += `<p><strong>Материалов:</strong> ${object.material.length}</p>`;
                    } else {
                        html += `<p><strong>Материал:</strong> ${object.material.type}</p>`;
                        
                        // Add material properties editing
                        if (object.material instanceof THREE.MeshStandardMaterial) {
                            html += `<div class="mt-2">`;
                            html += `<p><strong>Свойства материала:</strong></p>`;
                            
                            // Color picker
                            html += `<div class="flex items-center mt-1">`;
                            html += `<label class="mr-2">Цвет:</label>`;
                            html += `<input type="color" id="material-color" value="#${object.material.color.getHexString()}" class="w-8 h-8 border border-gray-600">`;
                            html += `</div>`;
                            
                            // Roughness slider
                            html += `<div class="mt-2">`;
                            html += `<label class="block">Шероховатость: <span id="roughness-value">${object.material.roughness.toFixed(2)}</span></label>`;
                            html += `<input type="range" id="material-roughness" min="0" max="1" step="0.01" value="${object.material.roughness}" class="w-full">`;
                            html += `</div>`;
                            
                            // Metalness slider
                            html += `<div class="mt-2">`;
                            html += `<label class="block">Металличность: <span id="metalness-value">${object.material.metalness.toFixed(2)}</span></label>`;
                            html += `<input type="range" id="material-metalness" min="0" max="1" step="0.01" value="${object.material.metalness}" class="w-full">`;
                            html += `</div>`;
                            
                            html += `</div>`;
                        }
                    }
                }
                html += `<p><strong>Видимый:</strong> ${object.visible}</p>`;
            }
            propertiesContentDiv.innerHTML = html;
            
            // Add event listeners for material property editing
            if (object.isMesh && object.material && !(object.material instanceof Array) && object.material instanceof THREE.MeshStandardMaterial) {
                // Color picker
                const colorPicker = document.getElementById('material-color');
                if (colorPicker) {
                    colorPicker.addEventListener('input', (e) => {
                        object.material.color.set(e.target.value);
                        object.material.needsUpdate = true;
                    });
                }
                
                // Roughness slider
                const roughnessSlider = document.getElementById('material-roughness');
                const roughnessValue = document.getElementById('roughness-value');
                if (roughnessSlider && roughnessValue) {
                    roughnessSlider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        object.material.roughness = value;
                        roughnessValue.textContent = value.toFixed(2);
                        object.material.needsUpdate = true;
                    });
                }
                
                // Metalness slider
                const metalnessSlider = document.getElementById('material-metalness');
                const metalnessValue = document.getElementById('metalness-value');
                if (metalnessSlider && metalnessValue) {
                    metalnessSlider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        object.material.metalness = value;
                        metalnessValue.textContent = value.toFixed(2);
                        object.material.needsUpdate = true;
                    });
                }
            }
        }
    
        // Build the tree from currentModel
        function buildSceneTree(searchTerm = '') {
            sceneTreeDiv.innerHTML = '';
            if (!currentModel) {
                sceneTreeDiv.innerHTML = '<p>Модель не загружена</p>';
                propertiesContentDiv.innerHTML = 'Выберите объект в дереве';
                return;
            }
            const rootItem = createTreeItem(currentModel, searchTerm);
            sceneTreeDiv.appendChild(rootItem);
        }
    
        // Rebuild tree when model changes
        const originalLoadFBX = loadFBX;
        loadFBX = function(file, fileName) {
            originalLoadFBX(file, fileName);
            setTimeout(buildSceneTree, 500);
        };
    
        const originalLoadGLTF = loadGLTF;
        loadGLTF = function(file, fileName) {
            originalLoadGLTF(file, fileName);
            setTimeout(buildSceneTree, 500);
        };
    
        // Display mode switching
        function setDisplayMode(mode) {
            if (!currentModel) return;
    
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    switch (mode) {
                        case 'standard':
                            if (child.material.originalWireframe !== undefined) {
                                child.material.wireframe = child.material.originalWireframe;
                            } else {
                                child.material.wireframe = false;
                            }
                            if (child.material.originalColor) {
                                child.material.color.copy(child.material.originalColor);
                            }
                            child.material.needsUpdate = true;
                            break;
                        case 'wireframe':
                            if (child.material.originalWireframe === undefined) {
                                child.material.originalWireframe = child.material.wireframe;
                            }
                            child.material.wireframe = true;
                            child.material.needsUpdate = true;
                            break;
                        case 'lighting':
                            // For lighting only, we can set material to MeshLambertMaterial with no map and white color
                            if (!child.userData.originalMaterial) {
                                child.userData.originalMaterial = child.material;
                            }
                            child.material = new THREE.MeshLambertMaterial({ color: 0xffffff });
                            child.material.needsUpdate = true;
                            break;
                    }
                }
            });
    
            // Restore original materials if switching back to standard
            if (mode === 'standard' && currentModel) {
                currentModel.traverse((child) => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                        delete child.userData.originalMaterial;
                        child.material.needsUpdate = true;
                    }
                });
            }
        }
    
        displayModeSelect.addEventListener('change', (event) => {
            setDisplayMode(event.target.value);
        });
    
    </script>
    </body>
    </html>
