<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX/GLTF Viewer with Modern UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #file-input-label, #reset-camera, .anim-btn {
            transition: all 0.3s ease;
        }
        #file-input-label:hover, #reset-camera:hover, .anim-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
        }
        #file-input {
            display: none;
        }
        #bg-color {
            transition: all 0.3s ease;
        }
        #bg-color:hover {
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        #progress {
            transition: opacity 0.3s ease;
        }
        /* Loading spinner inside progress text */
        #progress::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.8);
            border-top-color: #34d399;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 6px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-200">
    <div id="file-name" class="absolute top-4 left-1/2 transform -translate-x-1/2 text-white text-xl font-bold bg-gray-800 bg-opacity-75 px-4 py-2 rounded-lg"></div>
    <div id="error" class="absolute top-16 left-4 text-red-500 text-lg"></div>
    <div id="info" class="absolute top-4 right-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg">
        WSAD: Перемещение | Q/E: Вверх/Вниз | Мышь: Вращение/Масштаб
    </div>
    <div id="left-controls" class="absolute top-16 left-4 flex flex-col space-y-2 w-44">
        <label for="file-input" id="file-input-label" class="bg-green-500 text-white font-semibold py-2 px-3 rounded-lg cursor-pointer shadow-lg hover:bg-green-600 text-center block w-full">
            Выбрать файл
        </label>
        <input type="file" id="file-input" accept=".fbx,.gltf,.glb" class="hidden">
        <button id="reset-camera" class="bg-blue-500 text-white font-semibold py-2 px-3 rounded-lg cursor-pointer shadow-lg hover:bg-blue-600 w-full">
            Сбросить камеру
        </button>
        <select id="bg-color" class="bg-gray-800 text-white font-semibold py-2 px-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 w-full">
            <option value="#dddddd">Серый</option>
            <option value="#1e3a8a">Тёмно-синий</option>
            <option value="#000000">Чёрный</option>
            <option value="#ffffff">Белый</option>
        </select>
        <select id="display-mode" class="bg-gray-800 text-white font-semibold py-2 px-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 w-full">
            <option value="standard">Стандартный</option>
            <option value="wireframe">Каркасный</option>
            <option value="lighting">Только освещение</option>
        </select>
    </div>
    
    <!-- Элементы управления анимацией -->
    <div id="animation-controls" class="absolute top-52 left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden">
        <div class="mb-2">
            <select id="animation-select" class="bg-gray-700 text-white py-1 px-2 rounded text-sm">
                <option value="">Нет анимаций</option>
            </select>
        </div>
        <div class="flex items-center space-x-2 mb-2">
            <button id="play-pause-btn" class="anim-btn bg-green-600 hover:bg-green-700 px-2 py-1 rounded text-xs">
                ▶️ Играть
            </button>
            <button id="stop-btn" class="anim-btn bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-xs">
                ⏹️ Стоп
            </button>
            <input type="range" id="animation-slider" class="flex-1" min="0" max="100" value="0" step="0.1">
            <span id="duration-label" class="text-xs">0s</span>
        </div>
        <div class="flex items-center space-x-2 text-xs">
            <label>Скорость:</label>
            <input type="number" id="speed-input" class="w-12 bg-gray-700 text-white py-1 px-1 rounded text-xs" min="0.1" max="5" step="0.1" value="1">
            <label class="ml-2">
                <input type="checkbox" id="loop-checkbox" class="mr-1" checked>
                Зацикливать
            </label>
        </div>
    </div>
    <!-- Toggle button for inspector -->
    <button id="inspector-toggle" class="fixed top-4 right-4 z-[999] p-3 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5h12m-12 7h12m-12 7h12M1 5h12m-12 7h12m-12 7h12"/>
        </svg>
    </button>

    <!-- Scene inspector panel -->
    <div id="scene-inspector" class="fixed top-0 right-[-320px] h-full w-80 bg-gray-800 bg-opacity-95 text-white px-4 py-4 shadow-xl transition-all duration-300 ease-out overflow-y-auto z-40">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Инспектор сцены</h2>
            <button id="close-inspector" class="p-1 hover:bg-gray-700 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        <div id="scene-tree" class="text-sm mb-4 max-h-[70vh] overflow-auto border border-gray-600 rounded p-2 bg-gray-900"></div>
        <div id="object-properties" class="text-xs bg-gray-700 p-2 rounded max-h-40 overflow-auto">
            <h3 class="font-semibold mb-2">Свойства объекта</h3>
            <div id="properties-content">Выберите объект в дереве</div>
        </div>
    </div>

    
    <div id="progress" class="absolute top-52 left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden"></div>
    <div id="debug" class="absolute top-64 left-4 bg-gray-800 bg-opacity-75 text-white px-4 py-2 rounded-lg hidden"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        /* Additional styles for left controls uniform width */
        #left-controls > * {
            min-width: 100%;
            box-sizing: border-box;
        }
    </style>

    <script>
        // Инициализация сцены
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Улучшенное освещение
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Управление камерой
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();

        // Храним текущую модель и анимацию
        let currentModel = null;
        let mixer = null;
        let animations = [];
        let currentAction = null;
        let clock = new THREE.Clock();
        let isPlaying = false;
        let animationDuration = 0;
        let isSliderDragging = false;

        // Элементы управления анимацией
        const animationControls = document.getElementById('animation-controls');
        const animationSelect = document.getElementById('animation-select');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const animationSlider = document.getElementById('animation-slider');
        const durationLabel = document.getElementById('duration-label');
        const speedInput = document.getElementById('speed-input');
        const loopCheckbox = document.getElementById('loop-checkbox');

        // Функция обновления списка анимаций
        function updateAnimationList() {
            animationSelect.innerHTML = '<option value="">Нет анимаций</option>';
            
            if (animations.length > 0) {
                animations.forEach((clip, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${clip.name || `Анимация ${index + 1}`} (${clip.duration.toFixed(1)}s)`;
                    animationSelect.appendChild(option);
                });
                animationControls.classList.remove('hidden');
            } else {
                animationControls.classList.add('hidden');
            }
        }

        // Функция воспроизведения анимации
        function playAnimation(index) {
            if (!mixer || !animations[index]) {
                console.warn('Нет mixer или анимации');
                return;
            }

            // Остановка предыдущей анимации
            if (currentAction) {
                currentAction.stop();
                currentAction = null;
            }
            
            const clip = animations[index];
            currentAction = mixer.clipAction(clip);
            animationDuration = clip.duration;
            
            // Настройка циклов
            if (loopCheckbox.checked) {
                currentAction.setLoop(THREE.LoopRepeat, Infinity);
            } else {
                currentAction.setLoop(THREE.LoopOnce);
                currentAction.clampWhenFinished = true;
            }
            
            // Установка скорости и запуск
            currentAction.timeScale = parseFloat(speedInput.value) || 1;
            currentAction.reset();
            currentAction.play();
            
            isPlaying = true;
            playPauseBtn.textContent = '⏸️ Пауза';
            
            // Настройка слайдера
            animationSlider.max = animationDuration;
            animationSlider.value = 0;
            durationLabel.textContent = `${animationDuration.toFixed(1)}s`;
            
            console.log(`Запуск анимации: ${clip.name}, длительность: ${animationDuration}s`);
        }

        function stopAnimation() {
            if (currentAction) {
                currentAction.stop();
                currentAction.reset();
                currentAction = null;
            }
            isPlaying = false;
            playPauseBtn.textContent = '▶️ Играть';
            animationSlider.value = 0;
        }

        // Обработчики событий анимации
        animationSelect.addEventListener('change', (event) => {
            if (event.target.value !== '') {
                playAnimation(parseInt(event.target.value));
            } else {
                stopAnimation();
            }
        });

        playPauseBtn.addEventListener('click', () => {
            if (!currentAction) {
                // Если нет текущей анимации, попробовать запустить первую доступную
                if (animations.length > 0) {
                    animationSelect.value = 0;
                    playAnimation(0);
                }
                return;
            }
            
            if (isPlaying) {
                currentAction.paused = true;
                isPlaying = false;
                playPauseBtn.textContent = '▶️ Играть';
            } else {
                currentAction.paused = false;
                isPlaying = true;
                playPauseBtn.textContent = '⏸️ Пауза';
            }
        });

        stopBtn.addEventListener('click', () => {
            stopAnimation();
        });

        // Обработка слайдера времени
        animationSlider.addEventListener('mousedown', () => {
            isSliderDragging = true;
        });

        animationSlider.addEventListener('mouseup', () => {
            isSliderDragging = false;
        });

        animationSlider.addEventListener('input', (event) => {
            if (currentAction && animationDuration > 0) {
                const time = parseFloat(event.target.value);
                currentAction.time = time;
                if (mixer) {
                    mixer.setTime(time);
                }
            }
        });

        speedInput.addEventListener('input', (event) => {
            if (currentAction) {
                const speed = parseFloat(event.target.value) || 1;
                currentAction.timeScale = speed;
            }
        });

        loopCheckbox.addEventListener('change', (event) => {
            if (currentAction) {
                if (event.target.checked) {
                    currentAction.setLoop(THREE.LoopRepeat, Infinity);
                } else {
                    currentAction.setLoop(THREE.LoopOnce);
                    currentAction.clampWhenFinished = true;
                }
            }
        });

        // Fallback textures for missing maps
        const fallbackTextures = {
            diffuse: null,
            normal: null,
            roughness: null,
            metalness: null,
            specular: null
        };

        // Create fallback textures
        function createFallbackTextures() {
            // Create a simple 1x1 white texture for diffuse
            const whiteTexture = new THREE.DataTexture(new Uint8Array([255, 255, 255]), 1, 1, THREE.RGBFormat);
            whiteTexture.needsUpdate = true;
            fallbackTextures.diffuse = whiteTexture;

            // Create a simple 1x1 gray texture for roughness (middle gray = 0.5)
            const grayTexture = new THREE.DataTexture(new Uint8Array([128, 128, 128]), 1, 1, THREE.RGBFormat);
            grayTexture.needsUpdate = true;
            fallbackTextures.roughness = grayTexture;

            // Create a simple 1x1 black texture for metalness
            const blackTexture = new THREE.DataTexture(new Uint8Array([0, 0, 0]), 1, 1, THREE.RGBFormat);
            blackTexture.needsUpdate = true;
            fallbackTextures.metalness = blackTexture;

            // Create a simple 1x1 neutral normal map (forward vector)
            const neutralNormal = new THREE.DataTexture(new Uint8Array([128, 128, 255]), 1, 1, THREE.RGBFormat);
            neutralNormal.needsUpdate = true;
            fallbackTextures.normal = neutralNormal;
        }

        // Initialize fallback textures
        createFallbackTextures();

        // Enhanced material function with PBR support
        function enhanceMaterial(material) {
            // Convert to MeshStandardMaterial for PBR support if not already
            if (!(material instanceof THREE.MeshStandardMaterial)) {
                const newMaterial = new THREE.MeshStandardMaterial();
                
                // Copy basic properties
                newMaterial.name = material.name;
                newMaterial.color = material.color || new THREE.Color(0xcccccc);
                newMaterial.opacity = material.opacity !== undefined ? material.opacity : 1;
                newMaterial.transparent = material.transparent || false;
                newMaterial.side = material.side || THREE.FrontSide;
                newMaterial.visible = material.visible;
                newMaterial.wireframe = material.wireframe;
                
                // Handle diffuse map
                if (material.map) {
                    newMaterial.map = material.map;
                }
                
                // Try to extract PBR properties from the original material
                // FBX materials might have these properties
                if (material.specularMap) {
                    // In FBX, specular maps might be used for metalness
                    newMaterial.metalnessMap = material.specularMap;
                    newMaterial.metalness = 1.0;
                }
                
                // Set default PBR values if not specified
                if (newMaterial.metalness === undefined) {
                    newMaterial.metalness = 0.0;
                }
                
                if (newMaterial.roughness === undefined) {
                    newMaterial.roughness = 0.5;
                }
                
                // Replace the material
                material = newMaterial;
            }
            
            // Ensure all required maps are present
            if (!material.map) {
                material.map = fallbackTextures.diffuse;
            }
            
            // Set fallback textures for PBR maps if not present
            if (!material.roughnessMap) {
                // Try to derive roughness from shininess if available
                if (material.shininess !== undefined) {
                    material.roughness = Math.pow(1.0 - Math.min(1.0, material.shininess / 1000), 2);
                }
                material.roughnessMap = fallbackTextures.roughness;
            }
            
            if (!material.metalnessMap) {
                material.metalnessMap = fallbackTextures.metalness;
            }
            
            if (!material.normalMap) {
                material.normalMap = fallbackTextures.normal;
            }
            
            // Handle transparency
            if (material.opacity < 1.0 || material.transparent) {
                material.transparent = true;
                // For better transparency handling
                if (material.alphaTest === undefined) {
                    material.alphaTest = 0.01;
                }
            }
            
            // Handle double-sided materials
            if (material.side === THREE.DoubleSide) {
                material.side = THREE.DoubleSide;
            } else {
                // Check if material should be double-sided based on properties
                // This is a heuristic - materials with transparency are often double-sided
                if (material.opacity < 1.0) {
                    material.side = THREE.DoubleSide;
                }
            }
            
            // Enable material updates
            material.needsUpdate = true;
            
            return material;
        }
        // Функция загрузки FBX
        function loadFBX(file, fileName) {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            // Очистка анимации
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            animations = [];
            stopAnimation();
            
            const progressDiv = document.getElementById('progress');
            const debugDiv = document.getElementById('debug');
            progressDiv.classList.remove('hidden');
            debugDiv.classList.add('hidden');
            animationControls.classList.add('hidden');
            
            const loader = new THREE.FBXLoader();
            
            // Configure loader to handle textures properly
            loader.setPath('');
            loader.load(
                file,
                (fbx) => {
                    let meshCount = 0;
                    let materialCount = 0;
                    
                    fbx.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.material) {
                                materialCount++;
                                // Улучшение материалов с поддержкой PBR
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        enhanceMaterial(mat);
                                    });
                                } else {
                                    enhanceMaterial(child.material);
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Инициализация анимации
                    if (fbx.animations && fbx.animations.length > 0) {
                        console.log(`Найдено анимаций: ${fbx.animations.length}`);
                        fbx.animations.forEach((clip, i) => {
                            console.log(`Анимация ${i}: ${clip.name}, длительность: ${clip.duration}s`);
                        });
                        
                        mixer = new THREE.AnimationMixer(fbx);
                        animations = fbx.animations;
                    }
                    
                    console.log(`Модель ${fileName}: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`);
                    debugDiv.innerText = `Модель: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`;
                    debugDiv.classList.remove('hidden');
                    
                    if (meshCount === 0) {
                        document.getElementById('error').innerText = `Модель ${fileName} загружена, но не содержит видимой геометрии.`;
                        const placeholder = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({ color: 0xff0000 })
                        );
                        scene.add(placeholder);
                        currentModel = placeholder;
                    } else {
                        // Центрирование и масштабирование модели
                        const box = new THREE.Box3().setFromObject(fbx);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 1;
                        const scale = 2 / maxDim;
                        
                        fbx.scale.setScalar(scale);
                        fbx.position.copy(center.multiplyScalar(-scale));
                        
                        scene.add(fbx);
                        currentModel = fbx;
                        
                        // Настройка камеры
                        controls.target.set(0, 0, 0);
                        camera.position.set(
                            size.x * scale,
                            size.y * scale,
                            size.z * scale * 2
                        );
                        controls.update();
                        document.getElementById('error').innerText = '';
                    }
                    
                    updateAnimationList();
                    progressDiv.classList.add('hidden');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(2);
                        progressDiv.innerText = `Загрузка: ${percent}%`;
                    } else {
                        progressDiv.innerText = `Загрузка: ${(progress.loaded / 1024 / 1024).toFixed(2)} MB`;
                    }
                },
                (error) => {
                    console.error(`Ошибка загрузки ${fileName}:`, error);
                    document.getElementById('error').innerText = `Ошибка загрузки ${fileName}: ${error.message}`;
                    progressDiv.classList.add('hidden');
                    debugDiv.classList.add('hidden');
                }
            );
        }

        // Функция загрузки GLTF/GLB
        function loadGLTF(file, fileName) {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            
            // Очистка анимации
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            animations = [];
            stopAnimation();
            
            const progressDiv = document.getElementById('progress');
            const debugDiv = document.getElementById('debug');
            progressDiv.classList.remove('hidden');
            debugDiv.classList.add('hidden');
            animationControls.classList.add('hidden');
            
            const loader = new THREE.GLTFLoader();
            loader.load(
                file,
                (gltf) => {
                    let meshCount = 0;
                    let materialCount = 0;
                    
                    gltf.scene.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.material) {
                                materialCount++;
                                // Улучшение материалов с поддержкой PBR
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        enhanceMaterial(mat);
                                    });
                                } else {
                                    enhanceMaterial(child.material);
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Инициализация анимации
                    if (gltf.animations && gltf.animations.length > 0) {
                        console.log(`Найдено анимаций: ${gltf.animations.length}`);
                        gltf.animations.forEach((clip, i) => {
                            console.log(`Анимация ${i}: ${clip.name}, длительность: ${clip.duration}s`);
                        });
                        
                        mixer = new THREE.AnimationMixer(gltf.scene);
                        animations = gltf.animations;
                    }
                    
                    console.log(`Модель ${fileName}: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`);
                    debugDiv.innerText = `Модель: ${meshCount} мешей, ${materialCount} материалов, ${animations.length} анимаций`;
                    debugDiv.classList.remove('hidden');
                    
                    if (meshCount === 0) {
                        document.getElementById('error').innerText = `Модель ${fileName} загружена, но не содержит видимой геометрии.`;
                        const placeholder = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({ color: 0xff0000 })
                        );
                        scene.add(placeholder);
                        currentModel = placeholder;
                    } else {
                        // Центрирование и масштабирование модели
                        const box = new THREE.Box3().setFromObject(gltf.scene);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z) || 1;
                        const scale = 2 / maxDim;
                        
                        gltf.scene.scale.setScalar(scale);
                        gltf.scene.position.copy(center.multiplyScalar(-scale));
                        
                        scene.add(gltf.scene);
                        currentModel = gltf.scene;
                        
                        // Настройка камеры
                        controls.target.set(0, 0, 0);
                        camera.position.set(
                            size.x * scale,
                            size.y * scale,
                            size.z * scale * 2
                        );
                        controls.update();
                        document.getElementById('error').innerText = '';
                    }
                    
                    updateAnimationList();
                    progressDiv.classList.add('hidden');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(2);
                        progressDiv.innerText = `Загрузка: ${percent}%`;
                    } else {
                        progressDiv.innerText = `Загрузка: ${(progress.loaded / 1024 / 1024).toFixed(2)} MB`;
                    }
                },
                (error) => {
                    console.error(`Ошибка загрузки ${fileName}:`, error);
                    document.getElementById('error').innerText = `Ошибка загрузки ${fileName}: ${error.message}`;
                    progressDiv.classList.add('hidden');
                    debugDiv.classList.add('hidden');
                }
            );
        }

        // Обработка выбора файла
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('file-name').innerText = `Файл: ${file.name}`;
                const extension = file.name.split('.').pop().toLowerCase();
                console.log(`Выбранный файл: ${file.name}, расширение: ${extension}`);
                const url = URL.createObjectURL(file);
                
                if (extension === 'fbx') {
                    loadFBX(url, file.name);
                } else if (extension === 'gltf' || extension === 'glb') {
                    loadGLTF(url, file.name);
                } else {
                    document.getElementById('error').innerText = 'Поддерживаются только .fbx, .gltf, .glb';
                    document.getElementById('file-name').innerText = '';
                    document.getElementById('progress').classList.add('hidden');
                    document.getElementById('debug').classList.add('hidden');
                }
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }
        });

        // Сброс камеры
        document.getElementById('reset-camera').addEventListener('click', () => {
            camera.position.set(0, 0, 5);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        // Выбор цвета фона
        const bgColorSelect = document.getElementById('bg-color');
        bgColorSelect.addEventListener('change', (event) => {
            scene.background = new THREE.Color(event.target.value);
        });

        // Управление клавишами WSAD + Q/E
        const keys = { w: false, s: false, a: false, d: false, q: false, e: false };
        const moveSpeed = 0.1;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
                case 'KeyQ': keys.q = true; break;
                case 'KeyE': keys.e = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
                case 'KeyQ': keys.q = false; break;
                case 'KeyE': keys.e = false; break;
            }
        });

        // Основной цикл анимации
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Обновление анимации
            if (mixer && isPlaying) {
                mixer.update(delta);
                
                // Обновление слайдера времени (только если пользователь не перетаскивает)
                if (currentAction && !isSliderDragging) {
                    animationSlider.value = currentAction.time;
                    
                    // Проверка окончания анимации (для неповторяющихся)
                    if (!loopCheckbox.checked && currentAction.time >= animationDuration) {
                        isPlaying = false;
                        playPauseBtn.textContent = '▶️ Играть';
                    }
                }
            }
            
            // Управление камерой клавишами
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
            
            if (keys.w) {
                camera.position.addScaledVector(direction, moveSpeed);
                controls.target.addScaledVector(direction, moveSpeed);
            }
            if (keys.s) {
                camera.position.addScaledVector(direction, -moveSpeed);
                controls.target.addScaledVector(direction, -moveSpeed);
            }
            if (keys.a) {
                camera.position.addScaledVector(right, -moveSpeed);
                controls.target.addScaledVector(right, -moveSpeed);
            }
            if (keys.d) {
                camera.position.addScaledVector(right, moveSpeed);
                controls.target.addScaledVector(right, moveSpeed);
            }
            if (keys.q) {
                camera.position.y += moveSpeed;
                controls.target.y += moveSpeed;
            }
            if (keys.e) {
                camera.position.y -= moveSpeed;
                controls.target.y -= moveSpeed;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Адаптация к размеру окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    
        // --- Scene Inspector and Display Mode Switching ---
    
        const sceneTreeDiv = document.getElementById('scene-tree');
        const propertiesContentDiv = document.getElementById('properties-content');
        const displayModeSelect = document.getElementById('display-mode');
        
        // Inspector panel elements
        const inspector = document.getElementById('scene-inspector');
        const toggleBtn = document.getElementById('inspector-toggle');
        const closeBtn = document.getElementById('close-inspector');

        // Debug initial state
        console.log('Inspector element:', inspector);
        console.log('Toggle button:', toggleBtn);
        console.log('Close button:', closeBtn);

        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Toggle clicked - current right:', inspector.style.right);
            inspector.classList.toggle('right-0');
            inspector.classList.toggle('right-[-320px]');
            console.log('New right:', inspector.style.right);
        });

        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            inspector.classList.remove('right-0');
            inspector.classList.add('right-[-320px]');
        });

        document.addEventListener('click', (event) => {
            if (!inspector.contains(event.target) && !toggleBtn.contains(event.target)) {
                inspector.classList.remove('right-0');
                inspector.classList.add('right-[-320px]');
            }
        });

        inspector.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    
        // Helper function to create tree item elements recursively
        function createTreeItem(object) {
            const item = document.createElement('div');
            item.style.paddingLeft = '12px';
            item.style.cursor = 'pointer';
            item.textContent = object.name || object.type;
    
            // Visibility toggle checkbox
            const visibilityCheckbox = document.createElement('input');
            visibilityCheckbox.type = 'checkbox';
            visibilityCheckbox.checked = object.visible;
            visibilityCheckbox.style.marginRight = '6px';
    
            visibilityCheckbox.addEventListener('click', (event) => {
                event.stopPropagation();
                object.visible = visibilityCheckbox.checked;
            });
    
            item.prepend(visibilityCheckbox);
    
            // Expand/collapse children if any
            if (object.children && object.children.length > 0) {
                const expandBtn = document.createElement('span');
                expandBtn.textContent = '▶';
                expandBtn.style.display = 'inline-block';
                expandBtn.style.width = '12px';
                expandBtn.style.userSelect = 'none';
                expandBtn.style.marginRight = '4px';
                expandBtn.style.cursor = 'pointer';
    
                let expanded = false;
                const childrenContainer = document.createElement('div');
                childrenContainer.style.display = 'none';
    
                expandBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    expanded = !expanded;
                    childrenContainer.style.display = expanded ? 'block' : 'none';
                    expandBtn.textContent = expanded ? '▼' : '▶';
                });
    
                item.prepend(expandBtn);
    
                object.children.forEach(child => {
                    const childItem = createTreeItem(child);
                    childrenContainer.appendChild(childItem);
                });
    
                item.appendChild(childrenContainer);
            } else {
                // Add placeholder for alignment
                const placeholderSpan = document.createElement('span');
                placeholderSpan.style.display = 'inline-block';
                placeholderSpan.style.width = '16px';
                item.prepend(placeholderSpan);
            }
    
            // Selection handling
            item.addEventListener('click', (event) => {
                event.stopPropagation();
                selectObject(object, item);
            });
    
            return item;
        }
    
        let selectedItem = null;
        let selectedObject = null;
    
        function selectObject(object, itemElement) {
            if (selectedItem) {
                selectedItem.style.backgroundColor = '';
            }
            selectedItem = itemElement;
            selectedObject = object;
            selectedItem.style.backgroundColor = '#2563eb'; // blue highlight
    
            // Show properties
            showProperties(object);
        }
    
        function showProperties(object) {
            if (!object) {
                propertiesContentDiv.innerHTML = 'Выберите объект в дереве';
                return;
            }
            let html = `<p><strong>Имя:</strong> ${object.name || '(без имени)'}</p>`;
            html += `<p><strong>Тип:</strong> ${object.type}</p>`;
            if (object.isMesh) {
                html += `<p><strong>Вершин:</strong> ${object.geometry?.attributes?.position?.count || 'N/A'}</p>`;
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        html += `<p><strong>Материалов:</strong> ${object.material.length}</p>`;
                    } else {
                        html += `<p><strong>Материал:</strong> ${object.material.type}</p>`;
                    }
                }
                html += `<p><strong>Видимый:</strong> ${object.visible}</p>`;
            }
            propertiesContentDiv.innerHTML = html;
        }
    
        // Build the tree from currentModel
        function buildSceneTree() {
            sceneTreeDiv.innerHTML = '';
            if (!currentModel) {
                sceneTreeDiv.innerHTML = '<p>Модель не загружена</p>';
                propertiesContentDiv.innerHTML = 'Выберите объект в дереве';
                return;
            }
            const rootItem = createTreeItem(currentModel);
            sceneTreeDiv.appendChild(rootItem);
        }
    
        // Rebuild tree when model changes
        const originalLoadFBX = loadFBX;
        loadFBX = function(file, fileName) {
            originalLoadFBX(file, fileName);
            setTimeout(buildSceneTree, 500);
        };
    
        const originalLoadGLTF = loadGLTF;
        loadGLTF = function(file, fileName) {
            originalLoadGLTF(file, fileName);
            setTimeout(buildSceneTree, 500);
        };
    
        // Display mode switching
        function setDisplayMode(mode) {
            if (!currentModel) return;
    
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    switch (mode) {
                        case 'standard':
                            if (child.material.originalWireframe !== undefined) {
                                child.material.wireframe = child.material.originalWireframe;
                            } else {
                                child.material.wireframe = false;
                            }
                            if (child.material.originalColor) {
                                child.material.color.copy(child.material.originalColor);
                            }
                            child.material.needsUpdate = true;
                            break;
                        case 'wireframe':
                            if (child.material.originalWireframe === undefined) {
                                child.material.originalWireframe = child.material.wireframe;
                            }
                            child.material.wireframe = true;
                            child.material.needsUpdate = true;
                            break;
                        case 'lighting':
                            // For lighting only, we can set material to MeshLambertMaterial with no map and white color
                            if (!child.userData.originalMaterial) {
                                child.userData.originalMaterial = child.material;
                            }
                            child.material = new THREE.MeshLambertMaterial({ color: 0xffffff });
                            child.material.needsUpdate = true;
                            break;
                    }
                }
            });
    
            // Restore original materials if switching back to standard
            if (mode === 'standard' && currentModel) {
                currentModel.traverse((child) => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                        delete child.userData.originalMaterial;
                        child.material.needsUpdate = true;
                    }
                });
            }
        }
    
        displayModeSelect.addEventListener('change', (event) => {
            setDisplayMode(event.target.value);
        });
    
    </script>
    </body>
    </html>
